var documenterSearchIndex = {"docs":
[{"location":"benchmarks/#Performance-Benchmarks","page":"Benchmarks","title":"Performance Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Comprehensive performance analysis of the DMY algorithm implementation.","category":"page"},{"location":"benchmarks/#Experimental-Setup","page":"Benchmarks","title":"Experimental Setup","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Hardware: Julia 1.9+ on modern CPU\nGraph Types: Sparse random graphs (m ≈ 2n edges)\nBaseline: Simple Dijkstra implementation\nMethodology: 40 warm-up trials per solver, 95% confidence intervals\nSource: benchmark_results.txt and test/benchmark_performance.jl","category":"page"},{"location":"benchmarks/#Results","page":"Benchmarks","title":"Results","text":"","category":"section"},{"location":"benchmarks/#DMY-vs-Dijkstra","page":"Benchmarks","title":"DMY vs Dijkstra","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Graph Size Edges DMY (ms) ±95% CI Dijkstra (ms) ±95% CI Speedup\n200 400 0.081 ± 0.002 0.025 ± 0.001 0.31×\n500 1,000 0.426 ± 0.197 0.167 ± 0.004 0.39×\n1,000 2,000 1.458 ± 1.659 0.641 ± 0.008 0.44×\n2,000 4,000 1.415 ± 0.094 2.510 ± 0.038 1.77×\n5,000 10,000 3.346 ± 0.105 16.028 ± 0.241 4.79×","category":"page"},{"location":"benchmarks/#Key-Findings","page":"Benchmarks","title":"Key Findings","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Crossover point: DMY becomes faster than Dijkstra at approximately n ≈ 1,800 vertices\nScaling: DMY shows better asymptotic scaling as predicted by theory\nBest case: 4.79× speedup observed at n=5,000 vertices\nSparse graphs: Results are for graphs with m ≈ 2n (realistic for many applications)","category":"page"},{"location":"benchmarks/#Complexity-Analysis","page":"Benchmarks","title":"Complexity Analysis","text":"","category":"section"},{"location":"benchmarks/#Theoretical-Complexity","page":"Benchmarks","title":"Theoretical Complexity","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Algorithm Time Complexity Space Complexity\nDMY O(m log^(2/3) n) O(n + m)\nDijkstra O((m+n) log n) O(n + m)\nBellman-Ford O(mn) O(n + m)","category":"page"},{"location":"benchmarks/#Asymptotic-Comparison","page":"Benchmarks","title":"Asymptotic Comparison","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"For sparse graphs where m = O(n):","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Dijkstra: O(n log n)\nDMY: O(n log^(2/3) n)\nRatio: log^(1/3) n advantage for DMY","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"At n = 10,000:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"log^(1/3)(10,000) ≈ 4.64× theoretical speedup","category":"page"},{"location":"benchmarks/#Practical-Considerations","page":"Benchmarks","title":"Practical Considerations","text":"","category":"section"},{"location":"benchmarks/#When-DMY-is-Faster","page":"Benchmarks","title":"When DMY is Faster","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"✅ Large sparse graphs (n > 2,000, m ≈ 2n) ✅ Many shortest-path queries (amortize initialization cost) ✅ Academic/research applications","category":"page"},{"location":"benchmarks/#When-Dijkstra-is-Faster","page":"Benchmarks","title":"When Dijkstra is Faster","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"✅ Small graphs (n < 1,000) ✅ Dense graphs (m ≈ n²) ✅ Single query on simple graph","category":"page"},{"location":"benchmarks/#Recommendations","page":"Benchmarks","title":"Recommendations","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"n < 1,000: Use Dijkstra (built-in or LightGraphs.jl)\n1,000 < n < 2,000: Either algorithm works\nn > 2,000: Use DMY for better performance\nMulti-objective: Use OptimShortestPaths regardless of size (no simple alternative)","category":"page"},{"location":"benchmarks/#Running-Your-Own-Benchmarks","page":"Benchmarks","title":"Running Your Own Benchmarks","text":"","category":"section"},{"location":"benchmarks/#Quick-Benchmark","page":"Benchmarks","title":"Quick Benchmark","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using OptimShortestPaths\nusing BenchmarkTools\n\n# Create test graph\nn = 5000\nedges = Edge[]\nweights = Float64[]\nfor i in 1:n-1\n    push!(edges, Edge(i, i+1, length(edges)+1))\n    push!(weights, rand())\n    if rand() < 0.5  # Add some shortcuts\n        j = min(i + rand(2:100), n)\n        push!(edges, Edge(i, j, length(edges)+1))\n        push!(weights, rand(1.0:10.0))\n    end\nend\n\ngraph = DMYGraph(n, edges, weights)\n\n# Benchmark DMY\n@btime dmy_sssp!($graph, 1)","category":"page"},{"location":"benchmarks/#Comprehensive-Benchmark-Suite","page":"Benchmarks","title":"Comprehensive Benchmark Suite","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Run the full benchmark suite:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"julia --project=. test/benchmark_performance.jl","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"This generates benchmark_results.txt with detailed timing data for various graph sizes.","category":"page"},{"location":"benchmarks/#Multi-Objective-Performance","page":"Benchmarks","title":"Multi-Objective Performance","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Multi-objective optimization is inherently more expensive:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Operation Complexity Notes\nSingle objective O(m log^(2/3) n) Standard DMY\nWeighted sum O(m log^(2/3) n) Same as single\nPareto front O(k · m log^(2/3) n) k = Pareto set size\nε-constraint O(d · m log^(2/3) n) d = discretization steps","category":"page"},{"location":"benchmarks/#Pareto-Front-Size","page":"Benchmarks","title":"Pareto Front Size","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The Pareto set can grow exponentially with:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Number of objectives (2-3 manageable, 4+ slow)\nGraph structure (more paths = larger Pareto set)\nObjective correlation (conflicting objectives = more solutions)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Recommendation: Use max_solutions parameter to bound computation:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"pareto_front = compute_pareto_front(graph, source, target; max_solutions=1000)","category":"page"},{"location":"benchmarks/#Memory-Usage","page":"Benchmarks","title":"Memory Usage","text":"","category":"section"},{"location":"benchmarks/#Single-Objective-DMY","page":"Benchmarks","title":"Single-Objective DMY","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Graph storage: O(n + m)\nDistance array: O(n)\nFrontier sets: O(n) worst case\nTotal: O(n + m)","category":"page"},{"location":"benchmarks/#Multi-Objective-Pareto","page":"Benchmarks","title":"Multi-Objective Pareto","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Graph storage: O(d · (n + m)) where d = number of objectives\nSolution storage: O(k · p) where k = Pareto size, p = path length\nTotal: O(d·(n+m) + k·p)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"For n=1000, d=3, k=100, p=10: ≈ 10 KB (very efficient)","category":"page"},{"location":"benchmarks/#Algorithm-Details","page":"Benchmarks","title":"Algorithm Details","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The DMY algorithm uses:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"FindPivots: O(|U|) frontier sparsification\nBMSSP: O(k·B·m) bounded multi-source shortest path\nRecursive decomposition: O(log n) layers","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"These combine to achieve the O(m log^(2/3) n) bound.","category":"page"},{"location":"benchmarks/#Reproducibility","page":"Benchmarks","title":"Reproducibility","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"All benchmark data is canonical and version-controlled:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Data file: benchmark_results.txt\nGeneration script: test/benchmark_performance.jl\nFigures: Generated from canonical data via examples/comprehensive_demo/generate_figures.jl","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"To reproduce benchmarks on your hardware:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"julia --project=. test/benchmark_performance.jl > benchmark_results.txt\ncd examples/comprehensive_demo\njulia --project=. generate_figures.jl  # Regenerate with your data","category":"page"},{"location":"benchmarks/#See-Also","page":"Benchmarks","title":"See Also","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"API Reference for function signatures\nExamples for usage patterns\nGitHub Benchmarks for raw data","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Complete reference for all exported functions and types in OptimShortestPaths.","category":"page"},{"location":"api/#Core-Algorithm","page":"API Reference","title":"Core Algorithm","text":"","category":"section"},{"location":"api/#Main-Functions","page":"API Reference","title":"Main Functions","text":"","category":"section"},{"location":"api/#OptimShortestPaths.dmy_sssp!","page":"API Reference","title":"OptimShortestPaths.dmy_sssp!","text":"dmy_sssp!(graph::DMYGraph, source::Int) -> Vector{Float64}\n\nMain entry point for the DMY shortest-path algorithm. Computes single-source shortest paths from the given source vertex.\n\nArguments\n\ngraph: The directed graph with non-negative edge weights\nsource: Source vertex index (1-based)\n\nReturns\n\nVector of shortest distances from source to all vertices\n\nAlgorithm Overview\n\nThe DMY algorithm uses recursive layering with frontier sparsification:\n\nInitialize distance and parent arrays\nCall recursive_layer! with full vertex set\nReturn computed distances\n\nTime complexity: O(m log^(2/3) n) for sparse graphs Space complexity: O(n) for distance and parent arrays\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.dmy_sssp_with_parents!","page":"API Reference","title":"OptimShortestPaths.dmy_sssp_with_parents!","text":"dmy_sssp_with_parents!(graph::DMYGraph, source::Int) -> Tuple{Vector{Float64}, Vector{Int}}\n\nDMY algorithm that returns both distances and parent pointers for path reconstruction.\n\nReturns\n\nTuple of (distances, parents) where parents[v] gives the predecessor of v in shortest path tree\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.dmy_sssp_bounded!","page":"API Reference","title":"OptimShortestPaths.dmy_sssp_bounded!","text":"dmy_sssp_bounded!(graph::DMYGraph, source::Int, max_distance::Float64) -> Vector{Float64}\n\nDMY algorithm with distance bound - only computes paths up to max_distance. Can be more efficient when only short paths are needed.\n\nArguments\n\ngraph: The directed graph\nsource: Source vertex\nmax_distance: Maximum distance to compute (paths longer than this are ignored)\n\nReturns\n\nDistance array with INF for vertices beyond max_distance\n\n\n\n\n\n","category":"function"},{"location":"api/#Graph-Types","page":"API Reference","title":"Graph Types","text":"","category":"section"},{"location":"api/#OptimShortestPaths.DMYGraph","page":"API Reference","title":"OptimShortestPaths.DMYGraph","text":"DMYGraph\n\nEfficient graph representation for the DMY algorithm using adjacency lists. Stores vertices, edges, and weights with validation for non-negative weights.\n\n\n\n\n\n","category":"type"},{"location":"api/#OptimShortestPaths.Edge","page":"API Reference","title":"OptimShortestPaths.Edge","text":"Edge\n\nRepresents a directed edge in the graph with source, target vertices and weight index.\n\n\n\n\n\n","category":"type"},{"location":"api/#OptimShortestPaths.Block","page":"API Reference","title":"OptimShortestPaths.Block","text":"Block\n\nRepresents a partitioned block of vertices for recursive processing.\n\n\n\n\n\n","category":"type"},{"location":"api/#Algorithm-Components","page":"API Reference","title":"Algorithm Components","text":"","category":"section"},{"location":"api/#OptimShortestPaths.recursive_layer!","page":"API Reference","title":"OptimShortestPaths.recursive_layer!","text":"recursive_layer!(graph::DMYGraph, dist::Vector{Float64}, parent::Vector{Int},\n                U::Vector{Int}, S::OrderedSet{Int}, B::Float64) -> Nothing\n\nRecursive layer processing function that implements the core DMY algorithm logic. Processes vertex subset U with current frontier S and upper bound B.\n\nArguments\n\ngraph: The graph to process\ndist: Distance array (modified in-place)\nparent: Parent array for path reconstruction (modified in-place)\nU: Vertex subset to process\nS: Current frontier set\nB: Upper bound for distance updates\n\nThe function implements the recursive layering strategy with:\n\nBase case handling for small vertex sets\nPivot threshold calculation k = ⌈|U|^(1/3)⌉\nFrontier size checking and algorithm path selection\nPivot selection for frontier sparsification when needed\nVertex partitioning and recursive calls\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.bmssp!","page":"API Reference","title":"OptimShortestPaths.bmssp!","text":"bmssp!(graph::DMYGraph, dist::Vector{Float64}, parent::Vector{Int},\n       frontier::AbstractSet{Int}, bound::Float64, k::Int) -> OrderedSet{Int}\n\nPerform bounded multi-source shortest path relaxation for k rounds. Updates the distance and parent arrays in-place and returns the final frontier.\n\nArguments\n\ngraph: The graph to process\ndist: Distance array (modified in-place)\nparent: Parent array for path reconstruction (modified in-place)\nfrontier: Set of active vertices for relaxation\nbound: Upper bound for distance updates\nk: Maximum number of relaxation rounds\n\nReturns\n\nFinal frontier set after k rounds or early termination\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.bmssp_single_round!","page":"API Reference","title":"OptimShortestPaths.bmssp_single_round!","text":"bmssp_single_round!(graph::DMYGraph, dist::Vector{Float64}, parent::Vector{Int},\n                    frontier::AbstractSet{Int}, bound::Float64) -> Tuple{OrderedSet{Int}, Bool}\n\nPerform a single round of BMSSP relaxation. Returns the new frontier and whether any updates occurred.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.select_pivots","page":"API Reference","title":"OptimShortestPaths.select_pivots","text":"select_pivots(U_tilde::Vector{Int}, S::AbstractSet{Int}, k::Int, dist::Vector{Float64}) -> Vector{Int}\n\nSelect pivot vertices from U_tilde to sparsify the frontier. Uses distance-based clustering to choose representative vertices.\n\nArguments\n\nU_tilde: Filtered vertex set (vertices not in S with finite distance < bound)\nS: Current frontier set\nk: Pivot threshold (typically ⌈|U|^(1/3)⌉)\ndist: Current distance array\n\nReturns\n\nVector of selected pivot vertices with |P| ≤ |U_tilde| / k\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.partition_blocks","page":"API Reference","title":"OptimShortestPaths.partition_blocks","text":"partition_blocks(U::Vector{Int}, dist::Vector{Float64}, t::Int, B::Float64=INF) -> Vector{Block}\n\nPartition vertex set U into 2^t nearly equal blocks based on distance values. Each block gets a frontier seed and upper bound for recursive processing.\n\nArguments\n\nU: Vertex set to partition\ndist: Distance array\nt: Partition parameter (typically ⌈log^(1/3) n⌉)\nB: Overall bound for distances (default: INF)\n\nReturns\n\nVector of Block objects with vertices, frontier, and upper bound\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.partition_blocks_adaptive","page":"API Reference","title":"OptimShortestPaths.partition_blocks_adaptive","text":"partition_blocks_adaptive(U::Vector{Int}, dist::Vector{Float64}, t::Int, \n                         graph::DMYGraph, B::Float64=INF) -> Vector{Block}\n\nAdaptive block partitioning that considers graph structure and distance distribution. Creates more balanced blocks based on both distance and connectivity.\n\n\n\n\n\n","category":"function"},{"location":"api/#Validation","page":"API Reference","title":"Validation","text":"","category":"section"},{"location":"api/#OptimShortestPaths.validate_bmssp_input","page":"API Reference","title":"OptimShortestPaths.validate_bmssp_input","text":"validate_bmssp_input(graph::DMYGraph, dist::Vector{Float64}, parent::Vector{Int},\n                    frontier::AbstractSet{Int}, bound::Float64, k::Int) -> Bool\n\nValidate inputs for BMSSP function. Throws ArgumentError if invalid.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.validate_dmy_input","page":"API Reference","title":"OptimShortestPaths.validate_dmy_input","text":"validate_dmy_input(graph::DMYGraph, source::Int) -> Bool\n\nValidate inputs for DMY algorithm. Throws appropriate errors if invalid.\n\n\n\n\n\n","category":"function"},{"location":"api/#Statistics","page":"API Reference","title":"Statistics","text":"","category":"section"},{"location":"api/#OptimShortestPaths.bmssp_with_statistics!","page":"API Reference","title":"OptimShortestPaths.bmssp_with_statistics!","text":"bmssp_with_statistics!(graph::DMYGraph, dist::Vector{Float64}, parent::Vector{Int},\n                      frontier::AbstractSet{Int}, bound::Float64, k::Int) -> Dict{String, Any}\n\nPerform BMSSP with detailed statistics collection. Returns statistics about the relaxation process.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.dmy_algorithm_statistics","page":"API Reference","title":"OptimShortestPaths.dmy_algorithm_statistics","text":"dmy_algorithm_statistics(graph::DMYGraph, source::Int) -> Dict{String, Any}\n\nRun DMY algorithm with detailed statistics collection. Useful for algorithm analysis and performance tuning.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.count_relaxations","page":"API Reference","title":"OptimShortestPaths.count_relaxations","text":"count_relaxations(graph::DMYGraph, frontier::AbstractSet{Int}, bound::Float64, \n                 dist::Vector{Float64}) -> Int\n\nCount the number of edge relaxations that would be performed in the next round. Useful for algorithm analysis and debugging.\n\n\n\n\n\n","category":"function"},{"location":"api/#Multi-Objective-Optimization","page":"API Reference","title":"Multi-Objective Optimization","text":"","category":"section"},{"location":"api/#Main-Functions-2","page":"API Reference","title":"Main Functions","text":"","category":"section"},{"location":"api/#OptimShortestPaths.MultiObjective.compute_pareto_front","page":"API Reference","title":"OptimShortestPaths.MultiObjective.compute_pareto_front","text":"Compute the full Pareto front for multi-objective shortest paths. Returns all non-dominated paths from source to target.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.MultiObjective.get_knee_point","page":"API Reference","title":"OptimShortestPaths.MultiObjective.get_knee_point","text":"Find the \"knee point\" in the Pareto front - the solution with best trade-off. Uses the maximum distance from the utopia-nadir line.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.MultiObjective.compute_path_objectives","page":"API Reference","title":"OptimShortestPaths.MultiObjective.compute_path_objectives","text":"Compute objective values for a path given parent array. Optionally accepts a vector of edge indices (per vertex) that identifies which multi-objective edge was used to reach each vertex.\n\n\n\n\n\n","category":"function"},{"location":"api/#Optimization-Methods","page":"API Reference","title":"Optimization Methods","text":"","category":"section"},{"location":"api/#OptimShortestPaths.MultiObjective.weighted_sum_approach","page":"API Reference","title":"OptimShortestPaths.MultiObjective.weighted_sum_approach","text":"Weighted sum approach: Combine objectives with weights. Simple but may miss some Pareto-optimal solutions.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.MultiObjective.epsilon_constraint_approach","page":"API Reference","title":"OptimShortestPaths.MultiObjective.epsilon_constraint_approach","text":"Epsilon-constraint approach: Optimize one objective while constraining others. Good for finding specific trade-off solutions.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.MultiObjective.lexicographic_approach","page":"API Reference","title":"OptimShortestPaths.MultiObjective.lexicographic_approach","text":"Lexicographic approach: Optimize objectives in priority order. Good when objectives have clear priority ranking.\n\n\n\n\n\n","category":"function"},{"location":"api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/#OptimShortestPaths.MultiObjective.ParetoSolution","page":"API Reference","title":"OptimShortestPaths.MultiObjective.ParetoSolution","text":"A Pareto-optimal solution with multiple objective values\n\n\n\n\n\n","category":"type"},{"location":"api/#OptimShortestPaths.MultiObjective.MultiObjectiveGraph","page":"API Reference","title":"OptimShortestPaths.MultiObjective.MultiObjectiveGraph","text":"Multi-objective graph structure\n\n\n\n\n\n","category":"type"},{"location":"api/#OptimShortestPaths.MultiObjective.MultiObjectiveEdge","page":"API Reference","title":"OptimShortestPaths.MultiObjective.MultiObjectiveEdge","text":"Edge with multiple objective weights (e.g., distance, cost, risk, time)\n\n\n\n\n\n","category":"type"},{"location":"api/#Problem-Transformation","page":"API Reference","title":"Problem Transformation","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"The core innovation of OptimShortestPaths - transforming optimization problems into graphs.","category":"page"},{"location":"api/#OptimShortestPaths.OptimizationProblem","page":"API Reference","title":"OptimShortestPaths.OptimizationProblem","text":"OptimizationProblem(::Symbol, data, source)\n\nContainer for problem instances that can be transformed into a graph using the OptimShortestPaths casting helpers. data is the argument tuple that will be splatted into the corresponding constructor (e.g. create_drug_target_network).\n\n\n\n\n\n","category":"type"},{"location":"api/#OptimShortestPaths.optimize_to_graph","page":"API Reference","title":"OptimShortestPaths.optimize_to_graph","text":"Main OptimShortestPaths interface: optimize by casting to shortest path.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.cast_problem","page":"API Reference","title":"OptimShortestPaths.cast_problem","text":"Cast an optimization problem to a graph representation. This is the core innovation of OptimShortestPaths: transforming optimization into shortest paths.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.objectives_to_weights","page":"API Reference","title":"OptimShortestPaths.objectives_to_weights","text":"Transform optimization objectives into edge weights.\n\n\n\n\n\n","category":"function"},{"location":"api/#Domain-Specific-Applications","page":"API Reference","title":"Domain-Specific Applications","text":"","category":"section"},{"location":"api/#Pharmaceutical-Networks","page":"API Reference","title":"Pharmaceutical Networks","text":"","category":"section"},{"location":"api/#Types-2","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/#OptimShortestPaths.PharmaNetwork","page":"API Reference","title":"OptimShortestPaths.PharmaNetwork","text":"PharmaNetwork\n\nAbstract base type for pharmaceutical network representations.\n\n\n\n\n\n","category":"type"},{"location":"api/#OptimShortestPaths.DrugTargetNetwork","page":"API Reference","title":"OptimShortestPaths.DrugTargetNetwork","text":"DrugTargetNetwork <: PharmaNetwork\n\nRepresents drug-target interaction networks for pharmaceutical applications.\n\n\n\n\n\n","category":"type"},{"location":"api/#OptimShortestPaths.MetabolicPathway","page":"API Reference","title":"OptimShortestPaths.MetabolicPathway","text":"MetabolicPathway <: PharmaNetwork\n\nRepresents metabolic pathway networks with metabolites and enzymatic reactions.\n\n\n\n\n\n","category":"type"},{"location":"api/#OptimShortestPaths.TreatmentProtocol","page":"API Reference","title":"OptimShortestPaths.TreatmentProtocol","text":"TreatmentProtocol <: PharmaNetwork\n\nRepresents treatment protocol networks with treatment steps and transition costs.\n\n\n\n\n\n","category":"type"},{"location":"api/#Constructors","page":"API Reference","title":"Constructors","text":"","category":"section"},{"location":"api/#OptimShortestPaths.Pharma.create_drug_target_network","page":"API Reference","title":"OptimShortestPaths.Pharma.create_drug_target_network","text":"create_drug_target_network(drugs::Vector{String}, targets::Vector{String}, \n                          interactions::Matrix{Float64}) -> DrugTargetNetwork\n\nCreate a drug-target interaction network from drug names, target names, and interaction matrix. The interaction matrix contains binding affinities or interaction strengths.\n\nArguments\n\ndrugs: Vector of drug names\ntargets: Vector of target protein names  \ninteractions: Matrix where interactions[i,j] is the binding affinity between drug i and target j                Use 0.0 for no interaction, positive values for binding affinities\n\nReturns\n\nDrugTargetNetwork with underlying graph representation\n\nNetwork Structure\n\nVertices represent both drugs and targets\nEdges represent drug-target interactions\nEdge weights are -log(binding_affinity) to convert to distance metric\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.Pharma.create_metabolic_pathway","page":"API Reference","title":"OptimShortestPaths.Pharma.create_metabolic_pathway","text":"create_metabolic_pathway(metabolites::Vector{String}, reactions::Vector{String}, \n                       reaction_costs::Vector{Float64}, \n                       reaction_network::Vector{Tuple{String, String, String}}) -> MetabolicPathway\n\nCreate a metabolic pathway network from metabolites, reactions, and their connections.\n\nArguments\n\nmetabolites: Vector of metabolite names\nreactions: Vector of reaction names\nreaction_costs: Vector of costs for each reaction (energy, time, etc.)\nreaction_network: Vector of (substrate, reaction, product) tuples defining the pathway\n\nReturns\n\nMetabolicPathway with underlying graph representation\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.Pharma.create_treatment_protocol","page":"API Reference","title":"OptimShortestPaths.Pharma.create_treatment_protocol","text":"create_treatment_protocol(treatments::Vector{String}, costs::Vector{Float64}, \n                        efficacy_weights::Vector{Float64}, \n                        transitions::Vector{Tuple{String, String, Float64}}) -> TreatmentProtocol\n\nCreate a treatment protocol network for healthcare optimization.\n\nArguments\n\ntreatments: Vector of treatment step names\ncosts: Vector of costs for each treatment\nefficacy_weights: Vector of efficacy weights for each treatment\ntransitions: Vector of (fromtreatment, totreatment, transition_cost) tuples\n\nReturns\n\nTreatmentProtocol with underlying graph representation\n\n\n\n\n\n","category":"function"},{"location":"api/#Analysis-Functions","page":"API Reference","title":"Analysis Functions","text":"","category":"section"},{"location":"api/#OptimShortestPaths.Pharma.find_drug_target_paths","page":"API Reference","title":"OptimShortestPaths.Pharma.find_drug_target_paths","text":"find_drug_target_paths(network::DrugTargetNetwork, drug_name::String, \n                      target_name::String) -> Tuple{Float64, Vector{String}}\n\nFind the shortest path from a drug to a target in the network. Returns the path distance and the sequence of drugs/targets in the path.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.Pharma.analyze_drug_connectivity","page":"API Reference","title":"OptimShortestPaths.Pharma.analyze_drug_connectivity","text":"analyze_drug_connectivity(network::DrugTargetNetwork, drug_name::String) -> Dict{String, Any}\n\nAnalyze the connectivity of a specific drug in the network. Returns statistics about reachable targets and path lengths.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.Pharma.find_metabolic_pathway","page":"API Reference","title":"OptimShortestPaths.Pharma.find_metabolic_pathway","text":"find_metabolic_pathway(pathway::MetabolicPathway, start_metabolite::String, \n                      end_metabolite::String) -> Tuple{Float64, Vector{String}}\n\nFind the shortest metabolic pathway between two metabolites. Returns the total cost and sequence of metabolites in the pathway.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.Pharma.optimize_treatment_sequence","page":"API Reference","title":"OptimShortestPaths.Pharma.optimize_treatment_sequence","text":"optimize_treatment_sequence(protocol::TreatmentProtocol, start_treatment::String, \n                           end_treatment::String) -> Tuple{Float64, Vector{String}}\n\nFind the optimal treatment sequence from start to end treatment. Returns the total cost and sequence of treatments.\n\n\n\n\n\n","category":"function"},{"location":"api/#Generic-Graph-Utilities","page":"API Reference","title":"Generic Graph Utilities","text":"","category":"section"},{"location":"api/#Path-Operations","page":"API Reference","title":"Path Operations","text":"","category":"section"},{"location":"api/#OptimShortestPaths.find_shortest_path","page":"API Reference","title":"OptimShortestPaths.find_shortest_path","text":"find_shortest_path(graph::DMYGraph, source::Int, target::Int)\n\nFind the shortest path and distance between two vertices.\n\nReturns\n\nTuple of (distance, path) where path is vector of vertex indices\n\nExample\n\ndistance, path = find_shortest_path(graph, start, goal)\nif distance < INF\n    println(\"Path found: \", join(path, \" -> \"))\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.reconstruct_path","page":"API Reference","title":"OptimShortestPaths.reconstruct_path","text":"reconstruct_path(parent::Vector{Int}, source::Int, target::Int) -> Vector{Int}\n\nReconstruct the shortest path from source to target using parent pointers. Returns empty vector if no path exists.\n\nArguments\n\nparent: Parent array from DMY algorithm\nsource: Source vertex\ntarget: Target vertex\n\nReturns\n\nVector of vertices representing the path from source to target\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.shortest_path_tree","page":"API Reference","title":"OptimShortestPaths.shortest_path_tree","text":"shortest_path_tree(parent::Vector{Int}, source::Int) -> Dict{Int, Vector{Int}}\n\nConstruct the complete shortest path tree from the parent array. Returns a dictionary mapping each reachable vertex to its path from source.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.path_length","page":"API Reference","title":"OptimShortestPaths.path_length","text":"path_length(path::Vector{Int}, graph::DMYGraph) -> Float64\n\nCalculate the total length of a path in the graph. Returns INF if path is invalid or contains non-existent edges.\n\n\n\n\n\n","category":"function"},{"location":"api/#Connectivity-Analysis","page":"API Reference","title":"Connectivity Analysis","text":"","category":"section"},{"location":"api/#OptimShortestPaths.analyze_connectivity","page":"API Reference","title":"OptimShortestPaths.analyze_connectivity","text":"analyze_connectivity(graph::DMYGraph, source::Int)\n\nAnalyze connectivity metrics from a source vertex.\n\nReturns\n\nDictionary containing:\n\nreachable_count: Number of reachable vertices\nunreachable_count: Number of unreachable vertices  \navg_distance: Average distance to reachable vertices\nmax_distance: Maximum finite distance\nconnectivity_ratio: Fraction of vertices that are reachable\n\nExample\n\nmetrics = analyze_connectivity(graph, hub_vertex)\nprintln(\"Hub connectivity: \", metrics[\"connectivity_ratio\"] * 100, \"%\")\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.find_reachable_vertices","page":"API Reference","title":"OptimShortestPaths.find_reachable_vertices","text":"find_reachable_vertices(graph::DMYGraph, source::Int, max_distance::Float64 = INF)\n\nFind all vertices reachable from source within a maximum distance.\n\nArguments\n\ngraph: The graph to analyze\nsource: Source vertex\nmax_distance: Maximum distance threshold (default: INF for all reachable)\n\nReturns\n\nVector of vertex indices that are reachable within max_distance\n\nExample\n\n# Find all vertices within distance 10 from source\nnearby = find_reachable_vertices(graph, source, 10.0)\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.graph_reachability","page":"API Reference","title":"OptimShortestPaths.graph_reachability","text":"graph_reachability(graph::DMYGraph, source::Int) -> Set{Int}\n\nFind all vertices reachable from the source vertex. Uses simple BFS traversal.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.is_connected","page":"API Reference","title":"OptimShortestPaths.is_connected","text":"is_connected(graph::DMYGraph, source::Int, target::Int) -> Bool\n\nCheck if there is a direct edge from source to target vertex.\n\n\n\n\n\n","category":"function"},{"location":"api/#Distance-Metrics","page":"API Reference","title":"Distance Metrics","text":"","category":"section"},{"location":"api/#OptimShortestPaths.calculate_distance_ratio","page":"API Reference","title":"OptimShortestPaths.calculate_distance_ratio","text":"calculate_distance_ratio(graph::DMYGraph, source::Int, target1::Int, target2::Int)\n\nCalculate the ratio of distances from source to two different targets. This is a generic function useful for selectivity, preference, or comparison metrics.\n\nArguments\n\ngraph: The graph to analyze\nsource: Source vertex\ntarget1: First target vertex (numerator in ratio)\ntarget2: Second target vertex (denominator in ratio)\n\nReturns\n\nRatio of distance to target1 / distance to target2\nReturns 0.0 if either distance is 0 or unreachable\nReturns Inf if target2 is unreachable but target1 is reachable\n\nExample\n\n# For drug selectivity: higher ratio means more selective for target2\nratio = calculate_distance_ratio(graph, drug_vertex, cox1_vertex, cox2_vertex)\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.calculate_path_preference","page":"API Reference","title":"OptimShortestPaths.calculate_path_preference","text":"calculate_path_preference(graph::DMYGraph, source::Int, preferred::Int, alternative::Int)\n\nCalculate preference score for reaching one target over another from a source. Higher values indicate stronger preference for the preferred target.\n\nArguments\n\ngraph: The graph to analyze\nsource: Source vertex\npreferred: Preferred target vertex\nalternative: Alternative target vertex\n\nReturns\n\nPreference score (higher is better for preferred target)\nUses inverse distance ratio so lower distance = higher preference\n\nExample\n\n# Check if pathway A is preferred over pathway B\npreference = calculate_path_preference(graph, start, pathwayA, pathwayB)\nif preference > 1.5\n    println(\"Strong preference for pathway A\")\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.compare_sources","page":"API Reference","title":"OptimShortestPaths.compare_sources","text":"compare_sources(graph::DMYGraph, sources::Vector{Int}, target::Int)\n\nCompare distances from multiple sources to a single target.\n\nArguments\n\ngraph: The graph to analyze\nsources: Vector of source vertices to compare\ntarget: Target vertex\n\nReturns\n\nDictionary mapping source vertex to distance to target\n\nExample\n\n# Compare which warehouse is closest to customer\nwarehouses = [1, 2, 3]\ncustomer = 10\ndistances = compare_sources(graph, warehouses, customer)\nbest_warehouse = argmin(distances)\n\n\n\n\n\n","category":"function"},{"location":"api/#Graph-Properties","page":"API Reference","title":"Graph Properties","text":"","category":"section"},{"location":"api/#OptimShortestPaths.vertex_count","page":"API Reference","title":"OptimShortestPaths.vertex_count","text":"vertex_count(graph::DMYGraph) -> Int\n\nReturn the number of vertices in the graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.edge_count","page":"API Reference","title":"OptimShortestPaths.edge_count","text":"edge_count(graph::DMYGraph) -> Int\n\nReturn the number of edges in the graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.out_degree","page":"API Reference","title":"OptimShortestPaths.out_degree","text":"out_degree(graph::DMYGraph, vertex::Int) -> Int\n\nReturn the out-degree of the specified vertex.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.outgoing_edges","page":"API Reference","title":"OptimShortestPaths.outgoing_edges","text":"outgoing_edges(graph::DMYGraph, vertex::Int) -> Vector{Int}\n\nReturn the indices of all outgoing edges from the specified vertex.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.graph_density","page":"API Reference","title":"OptimShortestPaths.graph_density","text":"graph_density(graph::DMYGraph) -> Float64\n\nCalculate the density of the graph (ratio of actual edges to possible edges).\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.graph_statistics","page":"API Reference","title":"OptimShortestPaths.graph_statistics","text":"graph_statistics(graph::DMYGraph) -> Dict{String, Any}\n\nReturn comprehensive statistics about the graph structure.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.has_self_loops","page":"API Reference","title":"OptimShortestPaths.has_self_loops","text":"has_self_loops(graph::DMYGraph) -> Bool\n\nCheck if the graph contains any self-loops (edges from a vertex to itself).\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.get_vertices_by_out_degree","page":"API Reference","title":"OptimShortestPaths.get_vertices_by_out_degree","text":"get_vertices_by_out_degree(graph::DMYGraph) -> Vector{Tuple{Int,Int}}\n\nReturn vertices sorted by their out-degree in descending order. Returns vector of (vertex, out_degree) tuples.\n\n\n\n\n\n","category":"function"},{"location":"api/#Edge-Operations","page":"API Reference","title":"Edge Operations","text":"","category":"section"},{"location":"api/#OptimShortestPaths.get_edge","page":"API Reference","title":"OptimShortestPaths.get_edge","text":"get_edge(graph::DMYGraph, edge_index::Int) -> Edge\n\nReturn the edge at the specified index.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.get_edge_weight","page":"API Reference","title":"OptimShortestPaths.get_edge_weight","text":"get_edge_weight(graph::DMYGraph, edge_index::Int) -> Float64\n\nReturn the weight of the edge at the specified index.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.get_edge_weight_between","page":"API Reference","title":"OptimShortestPaths.get_edge_weight_between","text":"get_edge_weight_between(graph::DMYGraph, source::Int, target::Int) -> Union{Float64, Nothing}\n\nGet the weight of the edge from source to target, or return nothing if no edge exists. If multiple edges exist, returns the weight of the first one found.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.find_edge","page":"API Reference","title":"OptimShortestPaths.find_edge","text":"find_edge(graph::DMYGraph, source::Int, target::Int) -> Union{Int, Nothing}\n\nFind the index of the edge from source to target, or return nothing if not found. If multiple edges exist, returns the first one found.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.iterate_edges","page":"API Reference","title":"OptimShortestPaths.iterate_edges","text":"iterate_edges(graph::DMYGraph, vertex::Int)\n\nIterator for outgoing edges from a vertex. Returns (edge, weight) pairs.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.get_all_targets","page":"API Reference","title":"OptimShortestPaths.get_all_targets","text":"get_all_targets(graph::DMYGraph, source::Int) -> Vector{Int}\n\nGet all target vertices reachable directly from the source vertex.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graph-Construction","page":"API Reference","title":"Graph Construction","text":"","category":"section"},{"location":"api/#OptimShortestPaths.create_simple_graph","page":"API Reference","title":"OptimShortestPaths.create_simple_graph","text":"create_simple_graph(n_vertices::Int, edge_list::Vector{Tuple{Int,Int,Float64}}) -> DMYGraph\n\nCreate a DMYGraph from a simple edge list representation. Each tuple contains (source, target, weight).\n\n\n\n\n\n","category":"function"},{"location":"api/#Validation-and-Verification","page":"API Reference","title":"Validation & Verification","text":"","category":"section"},{"location":"api/#OptimShortestPaths.validate_graph","page":"API Reference","title":"OptimShortestPaths.validate_graph","text":"validate_graph(graph::DMYGraph) -> Bool\n\nValidate the structure and properties of a DMYGraph. Returns true if valid, throws ArgumentError if invalid.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.validate_vertex","page":"API Reference","title":"OptimShortestPaths.validate_vertex","text":"validate_vertex(graph::DMYGraph, vertex::Int) -> Bool\n\nValidate that a vertex index is within the valid range for the graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.verify_shortest_path","page":"API Reference","title":"OptimShortestPaths.verify_shortest_path","text":"verify_shortest_path(graph::DMYGraph, dist::Vector{Float64}, source::Int, target::Int) -> Bool\n\nVerify that the computed distance is indeed the shortest path length. Useful for debugging and validation.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.format_distance_results","page":"API Reference","title":"OptimShortestPaths.format_distance_results","text":"format_distance_results(dist::Vector{Float64}, source::Int) -> String\n\nFormat distance results for human-readable output.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comparison-and-Benchmarking","page":"API Reference","title":"Comparison & Benchmarking","text":"","category":"section"},{"location":"api/#OptimShortestPaths.compare_with_dijkstra","page":"API Reference","title":"OptimShortestPaths.compare_with_dijkstra","text":"compare_with_dijkstra(graph::DMYGraph, source::Int) -> Dict{String, Any}\n\nCompare DMY algorithm results with Dijkstra's algorithm for validation. Returns comparison statistics and identifies any discrepancies.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.simple_dijkstra","page":"API Reference","title":"OptimShortestPaths.simple_dijkstra","text":"simple_dijkstra(graph::DMYGraph, source::Int) -> Vector{Float64}\n\nSimple Dijkstra's algorithm implementation for comparison and validation. Not optimized for performance - used only for correctness checking.\n\n\n\n\n\n","category":"function"},{"location":"api/#Advanced-Functions","page":"API Reference","title":"Advanced Functions","text":"","category":"section"},{"location":"api/#Pivot-Selection","page":"API Reference","title":"Pivot Selection","text":"","category":"section"},{"location":"api/#OptimShortestPaths.calculate_pivot_threshold","page":"API Reference","title":"OptimShortestPaths.calculate_pivot_threshold","text":"calculate_pivot_threshold(U_size::Int) -> Int\n\nCalculate the pivot threshold k = ⌈|U|^(1/3)⌉ for a given vertex set size. This is the theoretical optimum from the DMY paper.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.calculate_partition_parameter","page":"API Reference","title":"OptimShortestPaths.calculate_partition_parameter","text":"calculate_partition_parameter(n::Int) -> Int\n\nCalculate the partition parameter t = ⌈log^(1/3) n⌉ for a given graph size. This determines the number of blocks (2^t) in recursive partitioning.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.pivot_selection_statistics","page":"API Reference","title":"OptimShortestPaths.pivot_selection_statistics","text":"pivot_selection_statistics(U_tilde::Vector{Int}, S::AbstractSet{Int}, k::Int,\n                          pivots::Vector{Int}, dist::Vector{Float64}) -> Dict{String, Any}\n\nCollect statistics about the pivot selection process.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.validate_pivot_selection","page":"API Reference","title":"OptimShortestPaths.validate_pivot_selection","text":"validate_pivot_selection(pivots::Vector{Int}, U_tilde::Vector{Int}, k::Int) -> Bool\n\nValidate that pivot selection satisfies the algorithm constraints. Checks that |P| ≤ |Utilde| / k and all pivots are from Utilde.\n\n\n\n\n\n","category":"function"},{"location":"api/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Complete working examples demonstrating OptimShortestPaths capabilities.","category":"page"},{"location":"examples/#Running-Examples","page":"Examples","title":"Running Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"All examples are located in the examples/ directory. Each has its own Project.toml for isolated dependencies.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To run an example:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"cd examples/drug_target_network\njulia --project=. -e \"using Pkg; Pkg.develop(path=\\\"../..\\\"); Pkg.instantiate()\"\njulia --project=. drug_target_network.jl","category":"page"},{"location":"examples/#Available-Examples","page":"Examples","title":"Available Examples","text":"","category":"section"},{"location":"examples/#1.-Comprehensive-Demo","page":"Examples","title":"1. Comprehensive Demo","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Location: examples/comprehensive_demo/","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Complete framework demonstration including:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Problem transformation philosophy\nAll three MCDA methods (weighted sum, ε-constraint, lexicographic)\nSupply chain optimization\nPerformance benchmarking\nAlgorithm capabilities showcase","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Generates: 7 publication-quality figures","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Run:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"cd examples/comprehensive_demo\njulia --project=. comprehensive_demo.jl\njulia --project=. generate_figures.jl  # Generate visualizations","category":"page"},{"location":"examples/#2.-Drug-Target-Network","page":"Examples","title":"2. Drug-Target Network","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Location: examples/drug_target_network/","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Analyzes drug-target binding affinities and selectivity:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"COX1/COX2 selectivity analysis\nMulti-objective cost-affinity-specificity optimization\nDrug connectivity metrics\nBinding affinity heatmaps","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Key insights: Demonstrates how thermodynamic binding affinities map to graph distances.","category":"page"},{"location":"examples/#3.-Metabolic-Pathway","page":"Examples","title":"3. Metabolic Pathway","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Location: examples/metabolic_pathway/","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Glycolysis pathway optimization (Embden-Meyerhof-Parnas):","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"ATP yield calculations\nByproduct analysis\nMulti-objective pathway comparison\nPareto front visualization","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Key insights: Shows bipartite metabolite-reaction network transformation.","category":"page"},{"location":"examples/#4.-Treatment-Protocol","page":"Examples","title":"4. Treatment Protocol","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Location: examples/treatment_protocol/","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Cancer treatment pathway optimization:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Multi-objective cost-time-quality-success trade-offs\nPatient-specific protocol recommendations\nClinical decision tree analysis\nTreatment sequence optimization","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Key insights: Handles complex multi-criteria clinical decisions.","category":"page"},{"location":"examples/#5.-Supply-Chain","page":"Examples","title":"5. Supply Chain","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Location: examples/supply_chain/","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Multi-echelon logistics network:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"3 factories → 4 warehouses → 5 distribution centers → 2 customer regions\n22-node network optimization\nFlow analysis and cost minimization\nNetwork topology visualization","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Key insights: Large-scale real-world graph optimization.","category":"page"},{"location":"examples/#6.-Generic-Utilities-Demo","page":"Examples","title":"6. Generic Utilities Demo","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Location: examples/generic_utilities_demo.jl","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Demonstrates domain-agnostic utility functions:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"find_shortest_path\ncalculate_distance_ratio\nanalyze_connectivity\nfind_reachable_vertices","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Key insights: Shows how generic functions work on any graph.","category":"page"},{"location":"examples/#Code-Examples","page":"Examples","title":"Code Examples","text":"","category":"section"},{"location":"examples/#Basic-Shortest-Path","page":"Examples","title":"Basic Shortest Path","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using OptimShortestPaths\n\n# Create graph\nedges = [Edge(1, 2, 1), Edge(2, 3, 2), Edge(1, 3, 3)]\nweights = [1.0, 2.0, 4.0]\ngraph = DMYGraph(3, edges, weights)\n\n# Find shortest path\ndistance, path = find_shortest_path(graph, 1, 3)\n# distance = 3.0, path = [1, 2, 3]","category":"page"},{"location":"examples/#Multi-Objective-Example","page":"Examples","title":"Multi-Objective Example","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Create multi-objective graph\nedges = [\n    MultiObjectiveEdge(1, 2, 1),\n    MultiObjectiveEdge(2, 3, 2),\n    MultiObjectiveEdge(1, 3, 3)\n]\n\n# [cost, time] for each edge\nobjectives = [\n    [1.0, 10.0],  # Cheap but slow\n    [2.0, 5.0],   # Moderate\n    [5.0, 3.0]    # Expensive but fast\n]\n\ngraph = MultiObjectiveGraph(3, edges, objectives)\n\n# Compute Pareto front\nsolutions = compute_pareto_front(graph, 1, 3)\n\n# Find best trade-off\nbest = get_knee_point(solutions)\nprintln(\"Best trade-off - Cost: $(best.objectives[1]), Time: $(best.objectives[2])\")","category":"page"},{"location":"examples/#Domain-Specific-Example","page":"Examples","title":"Domain-Specific Example","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Drug-target network\ndrugs = [\"Aspirin\", \"Ibuprofen\"]\ntargets = [\"COX1\", \"COX2\"]\naffinities = [\n    (\"Aspirin\", \"COX1\", 2.5),\n    (\"Aspirin\", \"COX2\", 3.2),\n    (\"Ibuprofen\", \"COX1\", 1.8),\n    (\"Ibuprofen\", \"COX2\", 2.1)\n]\n\nnetwork = create_drug_target_network(drugs, targets, affinities)\ndistance, path = find_drug_target_paths(network, \"Aspirin\", \"COX2\")","category":"page"},{"location":"examples/#Visualization-Examples","page":"Examples","title":"Visualization Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Each example directory includes generate_figures.jl for creating publication-quality visualizations:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"cd examples/comprehensive_demo\njulia --project=. generate_figures.jl\n# Generates 7 figures in figures/ directory","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Figures use professional aesthetics:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"300 DPI resolution\nBookman serif font\nNature/Science journal color palette\nPublication-ready quality","category":"page"},{"location":"examples/#See-Also","page":"Examples","title":"See Also","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Getting Started for basic usage\nAPI Reference for complete function documentation\nGitHub Examples for source code","category":"page"},{"location":"manual/domains/#Domain-Applications","page":"Domain Applications","title":"Domain Applications","text":"","category":"section"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"OptimShortestPaths provides built-in support for common application domains, particularly in pharmaceutical and healthcare optimization.","category":"page"},{"location":"manual/domains/#Drug-Target-Networks","page":"Domain Applications","title":"Drug-Target Networks","text":"","category":"section"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"Analyze drug-target interactions and selectivity.","category":"page"},{"location":"manual/domains/#Creating-a-Network","page":"Domain Applications","title":"Creating a Network","text":"","category":"section"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"using OptimShortestPaths\n\ndrugs = [\"Aspirin\", \"Ibuprofen\", \"Celecoxib\"]\ntargets = [\"COX1\", \"COX2\", \"5-LOX\", \"PGHS\"]\n\n# Binding affinities (lower = stronger binding)\naffinities = [\n    (\"Aspirin\", \"COX1\", 2.5),\n    (\"Aspirin\", \"COX2\", 3.2),\n    (\"Ibuprofen\", \"COX1\", 1.8),\n    (\"Ibuprofen\", \"COX2\", 2.1),\n    (\"Celecoxib\", \"COX2\", 0.5),  # Highly selective\n]\n\nnetwork = create_drug_target_network(drugs, targets, affinities)","category":"page"},{"location":"manual/domains/#Finding-Paths","page":"Domain Applications","title":"Finding Paths","text":"","category":"section"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"# Find shortest path from drug to target\ndistance, path = find_drug_target_paths(network, \"Aspirin\", \"COX2\")\nprintln(\"Binding affinity: \", distance)","category":"page"},{"location":"manual/domains/#Analyzing-Selectivity","page":"Domain Applications","title":"Analyzing Selectivity","text":"","category":"section"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"# Compare drug affinity for two targets\nratio = calculate_distance_ratio(network.graph, drug_idx, cox1_idx, cox2_idx)\nprintln(\"COX2/COX1 selectivity ratio: \", ratio)\n\n# Analyze overall connectivity\nstats = analyze_drug_connectivity(network, \"Celecoxib\")\nprintln(\"Reachable targets: \", stats)","category":"page"},{"location":"manual/domains/#Metabolic-Pathways","page":"Domain Applications","title":"Metabolic Pathways","text":"","category":"section"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"Optimize biochemical reaction pathways.","category":"page"},{"location":"manual/domains/#Creating-a-Pathway","page":"Domain Applications","title":"Creating a Pathway","text":"","category":"section"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"metabolites = [\"Glucose\", \"G6P\", \"F6P\", \"F16BP\", \"DHAP\", \"G3P\", \"PEP\", \"Pyruvate\", \"ATP\"]\n\nreactions = [\n    (\"Hexokinase\", \"Glucose\", \"G6P\", -1.0),      # ATP cost\n    (\"PGI\", \"G6P\", \"F6P\", 0.0),\n    (\"PFK\", \"F6P\", \"F16BP\", -1.0),               # ATP cost\n    (\"Aldolase\", \"F16BP\", \"DHAP\", 0.0),\n    (\"TPI\", \"DHAP\", \"G3P\", 0.0),\n    (\"GAPDH\", \"G3P\", \"PEP\", 2.0),                # ATP production\n    (\"PK\", \"PEP\", \"Pyruvate\", 2.0),              # ATP production\n]\n\npathway = create_metabolic_pathway(metabolites, reactions)","category":"page"},{"location":"manual/domains/#Finding-Optimal-Pathways","page":"Domain Applications","title":"Finding Optimal Pathways","text":"","category":"section"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"# Find pathway from substrate to product\natp_cost, pathway_steps = find_metabolic_pathway(pathway, \"Glucose\", \"Pyruvate\")\nprintln(\"Net ATP yield: \", -atp_cost)  # Negative cost = ATP production\nprintln(\"Pathway: \", pathway_steps)","category":"page"},{"location":"manual/domains/#Treatment-Protocols","page":"Domain Applications","title":"Treatment Protocols","text":"","category":"section"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"Optimize clinical treatment sequences.","category":"page"},{"location":"manual/domains/#Creating-a-Protocol","page":"Domain Applications","title":"Creating a Protocol","text":"","category":"section"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"treatments = [\"Initial\", \"ChemoA\", \"ChemoB\", \"Surgery\", \"Radiation\", \"Remission\"]\n\n# Costs in thousands of dollars\ncosts = [0.0, 50.0, 60.0, 100.0, 40.0, 0.0]\n\n# Efficacy weights (higher = better outcome)\nefficacy = [0.0, 0.6, 0.7, 0.8, 0.5, 1.0]\n\n# Valid treatment transitions (from, to, additional_risk)\ntransitions = [\n    (\"Initial\", \"ChemoA\", 0.1),\n    (\"Initial\", \"Surgery\", 0.3),\n    (\"ChemoA\", \"ChemoB\", 0.05),\n    (\"ChemoA\", \"Surgery\", 0.2),\n    (\"ChemoB\", \"Radiation\", 0.15),\n    (\"Surgery\", \"Radiation\", 0.1),\n    (\"Radiation\", \"Remission\", 0.05),\n]\n\nprotocol = create_treatment_protocol(treatments, costs, efficacy, transitions)","category":"page"},{"location":"manual/domains/#Optimizing-Sequences","page":"Domain Applications","title":"Optimizing Sequences","text":"","category":"section"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"# Find lowest-cost path to remission\ntotal_cost, sequence = optimize_treatment_sequence(protocol, \"Initial\", \"Remission\")\n\nprintln(\"Total cost: \\$\", total_cost * 1000)\nprintln(\"Optimal sequence: \", sequence)","category":"page"},{"location":"manual/domains/#Supply-Chain-Optimization","page":"Domain Applications","title":"Supply Chain Optimization","text":"","category":"section"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"For custom domains like supply chain, use the generic interface:","category":"page"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"# Entities: Factories, warehouses, distribution centers\n# Edges: Transportation links\n# Weights: Shipping cost + inventory holding cost\n\nfactories = 3\nwarehouses = 4\ndist_centers = 5\nn_vertices = factories + warehouses + dist_centers\n\nedges = Edge[]\nweights = Float64[]\n\n# Factory → Warehouse links\nfor f in 1:factories\n    for w in 1:warehouses\n        from = f\n        to = factories + w\n        transport_cost = rand(10:20)\n        push!(edges, Edge(from, to, length(edges)+1))\n        push!(weights, float(transport_cost))\n    end\nend\n\n# Warehouse → Distribution center links\nfor w in 1:warehouses\n    for d in 1:dist_centers\n        from = factories + w\n        to = factories + warehouses + d\n        cost = rand(5:15)\n        push!(edges, Edge(from, to, length(edges)+1))\n        push!(weights, float(cost))\n    end\nend\n\ngraph = DMYGraph(n_vertices, edges, weights)\n\n# Find optimal route from factory 1 to dist center 3\ntarget = factories + warehouses + 3\ndistances = dmy_sssp!(graph, 1)\nprintln(\"Minimum cost to DC 3: \\$\", distances[target])","category":"page"},{"location":"manual/domains/#Generic-Pattern","page":"Domain Applications","title":"Generic Pattern","text":"","category":"section"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"All domain applications follow this pattern:","category":"page"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"Define entities (metabolites, drugs, locations, etc.)\nDefine relationships (reactions, bindings, routes, etc.)\nAssign costs/weights (affinities, times, distances, etc.)\nCreate graph using domain constructor or generic DMYGraph\nRun algorithm to find optimal solutions","category":"page"},{"location":"manual/domains/#See-Also","page":"Domain Applications","title":"See Also","text":"","category":"section"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"Problem Transformation for general framework\nAPI Reference - Domain Functions\nExamples for complete worked examples","category":"page"},{"location":"manual/getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"This guide will help you get started with OptimShortestPaths.","category":"page"},{"location":"manual/getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.add(\"OptimShortestPaths\")","category":"page"},{"location":"manual/getting_started/#Your-First-Shortest-Path","page":"Getting Started","title":"Your First Shortest Path","text":"","category":"section"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"using OptimShortestPaths\n\n# Create a simple graph: 1 → 2 → 3\n#                        └─────→ 3\nedges = [\n    Edge(1, 2, 1),  # Edge from vertex 1 to 2 (id=1)\n    Edge(2, 3, 2),  # Edge from vertex 2 to 3 (id=2)\n    Edge(1, 3, 3)   # Direct edge from 1 to 3 (id=3)\n]\nweights = [1.0, 2.0, 4.0]  # Edge weights (costs)\n\ngraph = DMYGraph(3, edges, weights)\n\n# Run DMY algorithm from source vertex 1\ndistances = dmy_sssp!(graph, 1)\n\nprintln(\"Shortest distances from vertex 1:\")\nprintln(\"  to vertex 1: \", distances[1])  # 0.0\nprintln(\"  to vertex 2: \", distances[2])  # 1.0\nprintln(\"  to vertex 3: \", distances[3])  # 3.0 (via 1→2→3, not direct 1→3)","category":"page"},{"location":"manual/getting_started/#Path-Reconstruction","page":"Getting Started","title":"Path Reconstruction","text":"","category":"section"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"To get the actual path, not just distances:","category":"page"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Use variant that returns parent tree\ndistances, parent = dmy_sssp_with_parents!(graph, 1)\n\n# Reconstruct path from source to target\npath = reconstruct_path(parent, 1, 3)\nprintln(\"Path from 1 to 3: \", path)  # [1, 2, 3]","category":"page"},{"location":"manual/getting_started/#Using-High-Level-Interface","page":"Getting Started","title":"Using High-Level Interface","text":"","category":"section"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Even simpler - one function call\ndistance, path = find_shortest_path(graph, 1, 3)\nprintln(\"Distance: \", distance)  # 3.0\nprintln(\"Path: \", path)          # [1, 2, 3]","category":"page"},{"location":"manual/getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"","category":"section"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"Learn about Problem Transformation\nExplore Multi-Objective Optimization\nSee Domain Applications for real-world examples\nCheck API Reference for all functions","category":"page"},{"location":"manual/transformation/#Problem-Transformation","page":"Problem Transformation","title":"Problem Transformation","text":"","category":"section"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"The core innovation of OptimShortestPaths is transforming arbitrary optimization problems into shortest-path problems.","category":"page"},{"location":"manual/transformation/#The-Transformation-Framework","page":"Problem Transformation","title":"The Transformation Framework","text":"","category":"section"},{"location":"manual/transformation/#Step-1:-Identify-States","page":"Problem Transformation","title":"Step 1: Identify States","text":"","category":"section"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"Map your problem's decision points or configurations to graph vertices.","category":"page"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"Examples:","category":"page"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"Scheduling: Time slots × resources × task states\nPortfolio: Asset allocation configurations\nTreatment: Patient health states","category":"page"},{"location":"manual/transformation/#Step-2:-Define-Transitions","page":"Problem Transformation","title":"Step 2: Define Transitions","text":"","category":"section"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"Map valid actions or state changes to directed edges.","category":"page"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"Examples:","category":"page"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"Scheduling: Assigning a task to a resource\nPortfolio: Buying/selling an asset\nTreatment: Applying a specific treatment","category":"page"},{"location":"manual/transformation/#Step-3:-Quantify-Costs","page":"Problem Transformation","title":"Step 3: Quantify Costs","text":"","category":"section"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"Transform objectives into non-negative edge weights.","category":"page"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"Examples:","category":"page"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"Time to complete\nFinancial cost\nRisk score (must be ≥ 0)","category":"page"},{"location":"manual/transformation/#Step-4:-Solve-as-Shortest-Path","page":"Problem Transformation","title":"Step 4: Solve as Shortest Path","text":"","category":"section"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"Run the DMY algorithm to find optimal solutions.","category":"page"},{"location":"manual/transformation/#Using-the-Transformation-API","page":"Problem Transformation","title":"Using the Transformation API","text":"","category":"section"},{"location":"manual/transformation/#High-Level-Interface","page":"Problem Transformation","title":"High-Level Interface","text":"","category":"section"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"# Define your problem\nproblem = OptimizationProblem(\n    :drug_discovery,           # Problem type\n    (drugs, targets, affinities),  # Problem data\n    1                          # Source vertex\n)\n\n# Solve automatically\ndistances = optimize_to_graph(problem; solver=:dmy)","category":"page"},{"location":"manual/transformation/#Manual-Casting","page":"Problem Transformation","title":"Manual Casting","text":"","category":"section"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"# For custom problems\nfunction my_custom_cast(data)\n    # Extract problem-specific data\n    entities, transitions, costs = data\n\n    # Build edges\n    edges = Edge[]\n    weights = Float64[]\n    for (i, (from, to, cost)) in enumerate(transitions)\n        push!(edges, Edge(from, to, i))\n        push!(weights, cost)\n    end\n\n    # Create graph\n    n_vertices = length(entities)\n    return DMYGraph(n_vertices, edges, weights)\nend\n\n# Use it\ngraph = my_custom_cast(my_data)\ndistances = dmy_sssp!(graph, source)","category":"page"},{"location":"manual/transformation/#Domain-Agnostic-Examples","page":"Problem Transformation","title":"Domain-Agnostic Examples","text":"","category":"section"},{"location":"manual/transformation/#Resource-Scheduling","page":"Problem Transformation","title":"Resource Scheduling","text":"","category":"section"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"# States: Time slots (1-24) × Resources (A, B, C)\n# Edges: Task assignments\n# Weights: Completion time + setup cost\n\nn_time_slots = 24\nn_resources = 3\nn_vertices = n_time_slots * n_resources\n\n# Create edges for valid task assignments\nedges = Edge[]\nweights = Float64[]\n\nfor t in 1:(n_time_slots-1)\n    for r1 in 1:n_resources\n        for r2 in 1:n_resources\n            from_vertex = (t-1)*n_resources + r1\n            to_vertex = t*n_resources + r2\n\n            completion_time = 1.0\n            setup_cost = r1 == r2 ? 0.0 : 2.0  # Penalty for resource change\n\n            push!(edges, Edge(from_vertex, to_vertex, length(edges)+1))\n            push!(weights, completion_time + setup_cost)\n        end\n    end\nend\n\ngraph = DMYGraph(n_vertices, edges, weights)","category":"page"},{"location":"manual/transformation/#Network-Flow","page":"Problem Transformation","title":"Network Flow","text":"","category":"section"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"# States: Network nodes\n# Edges: Links with capacity constraints\n# Weights: Latency + congestion cost\n\n# Transform max-flow to shortest path by:\n# 1. Invert capacity: weight = 1/capacity\n# 2. Add congestion penalty\n# 3. Find min-cost path\n\nfunction capacity_to_weight(capacity, current_flow)\n    congestion = current_flow / capacity\n    return 1/capacity + 10.0 * congestion^2\nend","category":"page"},{"location":"manual/transformation/#Key-Constraints","page":"Problem Transformation","title":"Key Constraints","text":"","category":"section"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"warning: Non-Negative Weights Required\nThe DMY algorithm requires all edge weights ≥ 0. Transform maximization objectives:Revenue → Cost: weight = -revenue + baseline\nProbability → Distance: weight = -log(probability)\nSimilarity → Distance: weight = 1 - similarity","category":"page"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"info: Directed Graphs Only\nAll graphs must be directed. For undirected graphs, add edges in both directions.","category":"page"},{"location":"manual/transformation/#See-Also","page":"Problem Transformation","title":"See Also","text":"","category":"section"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"Multi-Objective Optimization for handling multiple objectives\nDomain Applications for pre-built transformation helpers\nAPI Reference for complete function documentation","category":"page"},{"location":"#OptimShortestPaths.jl","page":"Home","title":"OptimShortestPaths.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Transform optimization problems into graph shortest paths using the efficient DMY algorithm","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OptimShortestPaths is a Julia package that provides a unified framework for solving optimization problems by transforming them into shortest-path problems on directed graphs. The package implements the state-of-the-art DMY (Duan-Mao-Yin) algorithm from STOC 2025, achieving O(m log^(2/3) n) time complexity for single-source shortest paths.","category":"page"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Efficient Algorithm: DMY algorithm with O(m log^(2/3) n) complexity\nMulti-Objective: Pareto front computation with bounded solutions\nDomain-Agnostic: Transform ANY optimization problem to shortest paths\nDomain-Specific: Built-in support for drug discovery, metabolic networks, treatment protocols\nWell-Tested: 1,800+ test assertions with 100% pass rate\nPublication-Quality: Professional figures and comprehensive benchmarks","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"OptimShortestPaths\")\nusing OptimShortestPaths\n\n# Create a graph\nedges = [Edge(1, 2, 1), Edge(2, 3, 2), Edge(1, 3, 3)]\nweights = [1.0, 2.0, 4.0]\ngraph = DMYGraph(3, edges, weights)\n\n# Run DMY algorithm\ndistances = dmy_sssp!(graph, 1)  # Source vertex 1\nprintln(\"Distances: \", distances)  # [0.0, 1.0, 3.0]","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package requires Julia 1.9 or later:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"OptimShortestPaths\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"For development version:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.develop(\"OptimShortestPaths\")","category":"page"},{"location":"#Core-Concepts","page":"Home","title":"Core Concepts","text":"","category":"section"},{"location":"#Problem-Transformation-Philosophy","page":"Home","title":"Problem Transformation Philosophy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OptimShortestPaths transforms optimization problems into shortest-path problems:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Entities → Vertices: Map domain objects to graph vertices\nRelationships → Edges: Convert interactions/transitions to directed edges\nObjectives → Weights: Transform costs to non-negative edge weights\nSolutions → Paths: Shortest paths = optimal solutions","category":"page"},{"location":"#Why-This-Approach?","page":"Home","title":"Why This Approach?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Unified Framework: One algorithm solves many problems\nEfficient: O(m log^(2/3) n) complexity beats many domain-specific methods\nFlexible: Generic graph utilities work for any domain\nProven: Based on award-winning STOC 2025 algorithm","category":"page"},{"location":"#Main-Components","page":"Home","title":"Main Components","text":"","category":"section"},{"location":"#Core-Algorithm","page":"Home","title":"Core Algorithm","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"dmy_sssp! - Main DMY shortest path algorithm\nDMYGraph - Graph data structure\nbmssp! - Bounded Multi-Source Shortest Path subroutine","category":"page"},{"location":"#Multi-Objective-Optimization","page":"Home","title":"Multi-Objective Optimization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"compute_pareto_front - Pareto front computation\nweighted_sum_approach - Scalarization method\nepsilon_constraint_approach - ε-constraint method","category":"page"},{"location":"#Domain-Applications","page":"Home","title":"Domain Applications","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Drug-target network analysis\nMetabolic pathway optimization\nTreatment protocol sequencing\nSupply chain optimization","category":"page"},{"location":"#Performance","page":"Home","title":"Performance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Benchmarks on sparse random graphs (m ≈ 2n):","category":"page"},{"location":"","page":"Home","title":"Home","text":"Graph Size DMY Time Dijkstra Time Speedup\n200 0.08 ms 0.02 ms 0.31×\n500 0.43 ms 0.17 ms 0.39×\n1,000 1.46 ms 0.64 ms 0.44×\n2,000 1.42 ms 2.51 ms 1.77×\n5,000 3.35 ms 16.03 ms 4.79×","category":"page"},{"location":"","page":"Home","title":"Home","text":"DMY becomes faster than Dijkstra at approximately n ≈ 1,800 vertices.","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use OptimShortestPaths in your research, please cite:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@software{optimshortestpaths2025,\n  title = {OptimShortestPaths: Optimization via Shortest Paths},\n  author = {Tianchi Chen},\n  year = {2025},\n  url = {https://github.com/danielchen26/OptimShortestPaths.jl}\n}\n\n@inproceedings{dmy2025,\n  title = {Breaking the Dijkstra Barrier for Directed Single-Source Shortest-Paths via Structured Distances},\n  author = {Duan, Ran and Mao, Jiawei and Yin, Hao and Zhou, Hengming},\n  booktitle = {Proceedings of the 57th Annual ACM Symposium on Theory of Computing (STOC 2025)},\n  year = {2025},\n  note = {Best Paper Award}\n}","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributions are welcome! Please:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Add tests for new features\nUpdate benchmarks with your hardware specs\nCite relevant papers for algorithmic contributions\nFollow Julia style guidelines","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MIT License - see LICENSE file for details.","category":"page"},{"location":"#Acknowledgments","page":"Home","title":"Acknowledgments","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The DMY algorithm implementation is based on the STOC 2025 Best Paper by Duan, Mao, Yin, and Zhou.","category":"page"},{"location":"manual/multiobjective/#Multi-Objective-Optimization","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"","category":"section"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"OptimShortestPaths provides comprehensive support for multi-objective optimization through Pareto front computation.","category":"page"},{"location":"manual/multiobjective/#Overview","page":"Multi-Objective Optimization","title":"Overview","text":"","category":"section"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"When you have multiple conflicting objectives (e.g., minimize cost AND minimize time), there's no single \"best\" solution. Instead, you need to find the Pareto front - the set of solutions where improving one objective requires sacrificing another.","category":"page"},{"location":"manual/multiobjective/#Computing-the-Pareto-Front","page":"Multi-Objective Optimization","title":"Computing the Pareto Front","text":"","category":"section"},{"location":"manual/multiobjective/#Basic-Usage","page":"Multi-Objective Optimization","title":"Basic Usage","text":"","category":"section"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"using OptimShortestPaths\n\n# Create multi-objective graph\nedges = [MultiObjectiveEdge(1, 2, 1), MultiObjectiveEdge(2, 3, 2)]\nobjectives = [[1.0, 5.0], [2.0, 1.0]]  # [cost, time] for each edge\n\ngraph = MultiObjectiveGraph(3, edges, objectives)\n\n# Compute Pareto front\npareto_solutions = compute_pareto_front(graph, 1, 3; max_solutions=1000)\n\n# Each solution has:\nfor sol in pareto_solutions\n    println(\"Objectives: \", sol.objectives)  # [total_cost, total_time]\n    println(\"Path: \", sol.path)              # Vertex sequence\n    println(\"Edges: \", sol.edges)            # Edge IDs\nend","category":"page"},{"location":"manual/multiobjective/#Bounded-Pareto-Computation","page":"Multi-Objective Optimization","title":"Bounded Pareto Computation","text":"","category":"section"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"To prevent exponential growth of the Pareto set:","category":"page"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"pareto_solutions = compute_pareto_front(\n    graph, source, target;\n    max_solutions=1000  # Stop after 1000 solutions\n)","category":"page"},{"location":"manual/multiobjective/#Scalarization-Methods","page":"Multi-Objective Optimization","title":"Scalarization Methods","text":"","category":"section"},{"location":"manual/multiobjective/#Weighted-Sum-Approach","page":"Multi-Objective Optimization","title":"Weighted Sum Approach","text":"","category":"section"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"Convert multiple objectives into a single weighted sum:","category":"page"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"weights = [0.7, 0.3]  # 70% cost, 30% time\ndistance, path = weighted_sum_approach(graph, source, target, weights)","category":"page"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"warning: Minimization Only\nweighted_sum_approach currently requires all objectives to be minimization (:min). Transform maximization objectives first.","category":"page"},{"location":"manual/multiobjective/#Epsilon-Constraint-Method","page":"Multi-Objective Optimization","title":"Epsilon-Constraint Method","text":"","category":"section"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"Optimize one objective while constraining others:","category":"page"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"# Minimize cost subject to: time ≤ 10.0\ndistance, path = epsilon_constraint_approach(\n    graph, source, target,\n    1,              # Objective index to minimize (cost)\n    [Inf, 10.0]     # Constraints on objectives [cost, time]\n)","category":"page"},{"location":"manual/multiobjective/#Lexicographic-Optimization","page":"Multi-Objective Optimization","title":"Lexicographic Optimization","text":"","category":"section"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"Optimize objectives in priority order:","category":"page"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"priorities = [1, 2]  # First minimize obj 1 (cost), then obj 2 (time)\ndistance, path = lexicographic_approach(graph, source, target, priorities)","category":"page"},{"location":"manual/multiobjective/#Decision-Support","page":"Multi-Objective Optimization","title":"Decision Support","text":"","category":"section"},{"location":"manual/multiobjective/#Finding-the-Knee-Point","page":"Multi-Objective Optimization","title":"Finding the Knee Point","text":"","category":"section"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"The \"knee point\" offers the best trade-off between objectives:","category":"page"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"pareto_solutions = compute_pareto_front(graph, source, target)\n\n# Find solution with best trade-off\nbest_solution = get_knee_point(pareto_solutions)\n\nprintln(\"Best trade-off: \", best_solution.objectives)\nprintln(\"Path: \", best_solution.path)","category":"page"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"The knee point maximizes the angle between solutions, representing the steepest change in the Pareto curve.","category":"page"},{"location":"manual/multiobjective/#Working-with-Objective-Senses","page":"Multi-Objective Optimization","title":"Working with Objective Senses","text":"","category":"section"},{"location":"manual/multiobjective/#Minimization-and-Maximization","page":"Multi-Objective Optimization","title":"Minimization and Maximization","text":"","category":"section"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"# Define mixed objectives\nedges = [MultiObjectiveEdge(1, 2, 1)]\nobjectives = [[5.0, 8.0]]  # [cost_to_minimize, profit_to_maximize]\n\n# Specify senses\ngraph = MultiObjectiveGraph(\n    2, edges, objectives;\n    objective_sense = [:min, :max]  # Minimize cost, maximize profit\n)\n\n# Pareto front respects both senses\npareto_front = compute_pareto_front(graph, 1, 2)","category":"page"},{"location":"manual/multiobjective/#Converting-Maximization-to-Minimization","page":"Multi-Objective Optimization","title":"Converting Maximization to Minimization","text":"","category":"section"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"For scalarization methods that require :min:","category":"page"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"# Original: maximize profit\n# Transform: minimize negative profit\n\noriginal_profit = 100.0\nminimization_objective = -original_profit\n\n# Or subtract from baseline\nbaseline = 1000.0\nminimization_objective = baseline - original_profit","category":"page"},{"location":"manual/multiobjective/#Example:-Cost-Time-Trade-off","page":"Multi-Objective Optimization","title":"Example: Cost-Time Trade-off","text":"","category":"section"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"using OptimShortestPaths\n\n# Supply chain network: minimize cost AND time\nedges = [\n    MultiObjectiveEdge(1, 2, 1),\n    MultiObjectiveEdge(1, 3, 2),\n    MultiObjectiveEdge(2, 4, 3),\n    MultiObjectiveEdge(3, 4, 4)\n]\n\n# [cost, time] for each edge\nobjectives = [\n    [10.0, 1.0],  # Cheap but slow\n    [30.0, 0.5],  # Expensive but fast\n    [5.0, 2.0],   # Cheap and slow\n    [15.0, 1.0]   # Moderate\n]\n\ngraph = MultiObjectiveGraph(4, edges, objectives)\n\n# Find all Pareto-optimal paths\npareto_front = compute_pareto_front(graph, 1, 4)\n\nprintln(\"Found \", length(pareto_front), \" Pareto-optimal solutions:\")\nfor (i, sol) in enumerate(pareto_front)\n    println(\"  $i. Cost: $(sol.objectives[1]), Time: $(sol.objectives[2])\")\nend\n\n# Select best trade-off\nbest = get_knee_point(pareto_front)\nprintln(\"\\nBest trade-off: Cost=$(best.objectives[1]), Time=$(best.objectives[2])\")","category":"page"},{"location":"manual/multiobjective/#Performance-Considerations","page":"Multi-Objective Optimization","title":"Performance Considerations","text":"","category":"section"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"Pareto set size: Can grow exponentially; use max_solutions to bound it\nNumber of objectives: 2-3 objectives typical; 4+ can be slow\nGraph size: Pareto computation is slower than single-objective\nDominated solutions: Automatically filtered during computation","category":"page"},{"location":"manual/multiobjective/#See-Also","page":"Multi-Objective Optimization","title":"See Also","text":"","category":"section"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"API Reference - Multi-Objective\nExamples for more complex scenarios","category":"page"}]
}
