var documenterSearchIndex = {"docs":
[{"location":"examples/comprehensive_demo/","page":"Comprehensive Demo","title":"Comprehensive Demo","text":"begin\n    using Markdown\n    dashboard_path = joinpath(dirname(dirname(dirname(@__DIR__))), \"examples\", \"comprehensive_demo\", \"DASHBOARD.md\")\n    Markdown.parse(read(dashboard_path, String))\nend","category":"page"},{"location":"examples/drug_target_network/","page":"Drug-Target Networks","title":"Drug-Target Networks","text":"begin\n    using Markdown\n    dashboard_path = joinpath(dirname(dirname(dirname(@__DIR__))), \"examples\", \"drug_target_network\", \"DASHBOARD.md\")\n    Markdown.parse(read(dashboard_path, String))\nend","category":"page"},{"location":"manual/getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"This guide will help you get started with OptimShortestPaths.","category":"page"},{"location":"manual/getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.add(\"OptimShortestPaths\")","category":"page"},{"location":"manual/getting_started/#Your-First-Shortest-Path","page":"Getting Started","title":"Your First Shortest Path","text":"","category":"section"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"using OptimShortestPaths\n\n# Create a simple graph: 1 → 2 → 3\n#                        └─────→ 3\nedges = [\n    Edge(1, 2, 1),  # Edge from vertex 1 to 2 (id=1)\n    Edge(2, 3, 2),  # Edge from vertex 2 to 3 (id=2)\n    Edge(1, 3, 3)   # Direct edge from 1 to 3 (id=3)\n]\nweights = [1.0, 2.0, 4.0]  # Edge weights (costs)\n\ngraph = DMYGraph(3, edges, weights)\n\n# Run DMY algorithm from source vertex 1\ndistances = dmy_sssp!(graph, 1)\n\nprintln(\"Shortest distances from vertex 1:\")\nprintln(\"  to vertex 1: \", distances[1])  # 0.0\nprintln(\"  to vertex 2: \", distances[2])  # 1.0\nprintln(\"  to vertex 3: \", distances[3])  # 3.0 (via 1→2→3, not direct 1→3)","category":"page"},{"location":"manual/getting_started/#Path-Reconstruction","page":"Getting Started","title":"Path Reconstruction","text":"","category":"section"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"To get the actual path, not just distances:","category":"page"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Use variant that returns parent tree\ndistances, parent = dmy_sssp_with_parents!(graph, 1)\n\n# Reconstruct path from source to target\npath = reconstruct_path(parent, 1, 3)\nprintln(\"Path from 1 to 3: \", path)  # [1, 2, 3]","category":"page"},{"location":"manual/getting_started/#Using-High-Level-Interface","page":"Getting Started","title":"Using High-Level Interface","text":"","category":"section"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"# Even simpler - one function call\ndistance, path = find_shortest_path(graph, 1, 3)\nprintln(\"Distance: \", distance)  # 3.0\nprintln(\"Path: \", path)          # [1, 2, 3]","category":"page"},{"location":"manual/getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"","category":"section"},{"location":"manual/getting_started/","page":"Getting Started","title":"Getting Started","text":"Learn about Problem Transformation\nExplore Multi-Objective Optimization\nSee Domain Applications for real-world examples\nCheck API Reference for all functions","category":"page"},{"location":"benchmarks/#Performance-Benchmarks","page":"Benchmarks","title":"Performance Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Comprehensive performance analysis of the DMY algorithm implementation.","category":"page"},{"location":"benchmarks/#Experimental-Setup","page":"Benchmarks","title":"Experimental Setup","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Hardware: Julia 1.9+ on modern CPU\nGraph Types: Sparse random graphs (m ≈ 2n edges)\nBaseline: Simple Dijkstra implementation\nMethodology: 40 warm-up trials per solver, 95% confidence intervals\nSource: benchmark_results.txt and test/benchmark_performance.jl","category":"page"},{"location":"benchmarks/#Results","page":"Benchmarks","title":"Results","text":"","category":"section"},{"location":"benchmarks/#DMY-vs-Dijkstra","page":"Benchmarks","title":"DMY vs Dijkstra","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Graph Size Edges DMY (ms) ±95% CI Dijkstra (ms) ±95% CI Speedup\n200 400 0.081 ± 0.002 0.025 ± 0.001 0.31×\n500 1,000 0.426 ± 0.197 0.167 ± 0.004 0.39×\n1,000 2,000 1.458 ± 1.659 0.641 ± 0.008 0.44×\n2,000 4,000 1.415 ± 0.094 2.510 ± 0.038 1.77×\n5,000 10,000 3.346 ± 0.105 16.028 ± 0.241 4.79×","category":"page"},{"location":"benchmarks/#Key-Findings","page":"Benchmarks","title":"Key Findings","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Crossover point: DMY becomes faster than Dijkstra at approximately n ≈ 1,800 vertices\nScaling: DMY shows better asymptotic scaling as predicted by theory\nBest case: 4.79× speedup observed at n=5,000 vertices\nSparse graphs: Results are for graphs with m ≈ 2n (realistic for many applications)","category":"page"},{"location":"benchmarks/#Complexity-Analysis","page":"Benchmarks","title":"Complexity Analysis","text":"","category":"section"},{"location":"benchmarks/#Theoretical-Complexity","page":"Benchmarks","title":"Theoretical Complexity","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Algorithm Time Complexity Space Complexity\nDMY O(m log^(2/3) n) O(n + m)\nDijkstra O((m+n) log n) O(n + m)\nBellman-Ford O(mn) O(n + m)","category":"page"},{"location":"benchmarks/#Asymptotic-Comparison","page":"Benchmarks","title":"Asymptotic Comparison","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"For sparse graphs where m = O(n):","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Dijkstra: O(n log n)\nDMY: O(n log^(2/3) n)\nRatio: log^(1/3) n advantage for DMY","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"At n = 10,000:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"log^(1/3)(10,000) ≈ 4.64× theoretical speedup","category":"page"},{"location":"benchmarks/#Practical-Considerations","page":"Benchmarks","title":"Practical Considerations","text":"","category":"section"},{"location":"benchmarks/#When-DMY-is-Faster","page":"Benchmarks","title":"When DMY is Faster","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"✅ Large sparse graphs (n > 2,000, m ≈ 2n) ✅ Many shortest-path queries (amortize initialization cost) ✅ Academic/research applications","category":"page"},{"location":"benchmarks/#When-Dijkstra-is-Faster","page":"Benchmarks","title":"When Dijkstra is Faster","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"✅ Small graphs (n < 1,000) ✅ Dense graphs (m ≈ n²) ✅ Single query on simple graph","category":"page"},{"location":"benchmarks/#Recommendations","page":"Benchmarks","title":"Recommendations","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"n < 1,000: Use Dijkstra (built-in or LightGraphs.jl)\n1,000 < n < 2,000: Either algorithm works\nn > 2,000: Use DMY for better performance\nMulti-objective: Use OptimShortestPaths regardless of size (no simple alternative)","category":"page"},{"location":"benchmarks/#Running-Your-Own-Benchmarks","page":"Benchmarks","title":"Running Your Own Benchmarks","text":"","category":"section"},{"location":"benchmarks/#Quick-Benchmark","page":"Benchmarks","title":"Quick Benchmark","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using OptimShortestPaths\nusing BenchmarkTools\n\n# Create test graph\nn = 5000\nedges = Edge[]\nweights = Float64[]\nfor i in 1:n-1\n    push!(edges, Edge(i, i+1, length(edges)+1))\n    push!(weights, rand())\n    if rand() < 0.5  # Add some shortcuts\n        j = min(i + rand(2:100), n)\n        push!(edges, Edge(i, j, length(edges)+1))\n        push!(weights, rand(1.0:10.0))\n    end\nend\n\ngraph = DMYGraph(n, edges, weights)\n\n# Benchmark DMY\n@btime dmy_sssp!($graph, 1)","category":"page"},{"location":"benchmarks/#Comprehensive-Benchmark-Suite","page":"Benchmarks","title":"Comprehensive Benchmark Suite","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Run the full benchmark suite:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"julia --project=. test/benchmark_performance.jl","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"This generates benchmark_results.txt with detailed timing data for various graph sizes.","category":"page"},{"location":"benchmarks/#Multi-Objective-Performance","page":"Benchmarks","title":"Multi-Objective Performance","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Multi-objective optimization is inherently more expensive:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Operation Complexity Notes\nSingle objective O(m log^(2/3) n) Standard DMY\nWeighted sum O(m log^(2/3) n) Same as single\nPareto front O(k · m log^(2/3) n) k = Pareto set size\nε-constraint O(d · m log^(2/3) n) d = discretization steps","category":"page"},{"location":"benchmarks/#Pareto-Front-Size","page":"Benchmarks","title":"Pareto Front Size","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The Pareto set can grow exponentially with:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Number of objectives (2-3 manageable, 4+ slow)\nGraph structure (more paths = larger Pareto set)\nObjective correlation (conflicting objectives = more solutions)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Recommendation: Use max_solutions parameter to bound computation:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"pareto_front = compute_pareto_front(graph, source, target; max_solutions=1000)","category":"page"},{"location":"benchmarks/#Memory-Usage","page":"Benchmarks","title":"Memory Usage","text":"","category":"section"},{"location":"benchmarks/#Single-Objective-DMY","page":"Benchmarks","title":"Single-Objective DMY","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Graph storage: O(n + m)\nDistance array: O(n)\nFrontier sets: O(n) worst case\nTotal: O(n + m)","category":"page"},{"location":"benchmarks/#Multi-Objective-Pareto","page":"Benchmarks","title":"Multi-Objective Pareto","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Graph storage: O(d · (n + m)) where d = number of objectives\nSolution storage: O(k · p) where k = Pareto size, p = path length\nTotal: O(d·(n+m) + k·p)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"For n=1000, d=3, k=100, p=10: ≈ 10 KB (very efficient)","category":"page"},{"location":"benchmarks/#Algorithm-Details","page":"Benchmarks","title":"Algorithm Details","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The DMY algorithm uses:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"FindPivots: O(|U|) frontier sparsification\nBMSSP: O(k·B·m) bounded multi-source shortest path\nRecursive decomposition: O(log n) layers","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"These combine to achieve the O(m log^(2/3) n) bound.","category":"page"},{"location":"benchmarks/#Reproducibility","page":"Benchmarks","title":"Reproducibility","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"All benchmark data is canonical and version-controlled:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Data file: benchmark_results.txt\nGeneration script: test/benchmark_performance.jl\nFigures: Generated from canonical data via examples/comprehensive_demo/generate_figures.jl","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"To reproduce benchmarks on your hardware:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"julia --project=. test/benchmark_performance.jl > benchmark_results.txt\ncd examples/comprehensive_demo\njulia --project=. generate_figures.jl  # Regenerate with your data","category":"page"},{"location":"benchmarks/#See-Also","page":"Benchmarks","title":"See Also","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"API Reference for function signatures\nExamples for usage patterns\nGitHub Benchmarks for raw data","category":"page"},{"location":"manual/transformation/#Problem-Transformation","page":"Problem Transformation","title":"Problem Transformation","text":"","category":"section"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"The core innovation of OptimShortestPaths is transforming arbitrary optimization problems into shortest-path problems.","category":"page"},{"location":"manual/transformation/#The-Transformation-Framework","page":"Problem Transformation","title":"The Transformation Framework","text":"","category":"section"},{"location":"manual/transformation/#Step-1:-Identify-States","page":"Problem Transformation","title":"Step 1: Identify States","text":"","category":"section"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"Map your problem's decision points or configurations to graph vertices.","category":"page"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"Examples:","category":"page"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"Scheduling: Time slots × resources × task states\nPortfolio: Asset allocation configurations\nTreatment: Patient health states","category":"page"},{"location":"manual/transformation/#Step-2:-Define-Transitions","page":"Problem Transformation","title":"Step 2: Define Transitions","text":"","category":"section"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"Map valid actions or state changes to directed edges.","category":"page"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"Examples:","category":"page"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"Scheduling: Assigning a task to a resource\nPortfolio: Buying/selling an asset\nTreatment: Applying a specific treatment","category":"page"},{"location":"manual/transformation/#Step-3:-Quantify-Costs","page":"Problem Transformation","title":"Step 3: Quantify Costs","text":"","category":"section"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"Transform objectives into non-negative edge weights.","category":"page"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"Examples:","category":"page"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"Time to complete\nFinancial cost\nRisk score (must be ≥ 0)","category":"page"},{"location":"manual/transformation/#Step-4:-Solve-as-Shortest-Path","page":"Problem Transformation","title":"Step 4: Solve as Shortest Path","text":"","category":"section"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"Run the DMY algorithm to find optimal solutions.","category":"page"},{"location":"manual/transformation/#Using-the-Transformation-API","page":"Problem Transformation","title":"Using the Transformation API","text":"","category":"section"},{"location":"manual/transformation/#High-Level-Interface","page":"Problem Transformation","title":"High-Level Interface","text":"","category":"section"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"# Define your problem\nproblem = OptimizationProblem(\n    :drug_discovery,           # Problem type\n    (drugs, targets, affinities),  # Problem data\n    1                          # Source vertex\n)\n\n# Solve automatically\ndistances = optimize_to_graph(problem; solver=:dmy)","category":"page"},{"location":"manual/transformation/#Manual-Casting","page":"Problem Transformation","title":"Manual Casting","text":"","category":"section"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"# For custom problems\nfunction my_custom_cast(data)\n    # Extract problem-specific data\n    entities, transitions, costs = data\n\n    # Build edges\n    edges = Edge[]\n    weights = Float64[]\n    for (i, (from, to, cost)) in enumerate(transitions)\n        push!(edges, Edge(from, to, i))\n        push!(weights, cost)\n    end\n\n    # Create graph\n    n_vertices = length(entities)\n    return DMYGraph(n_vertices, edges, weights)\nend\n\n# Use it\ngraph = my_custom_cast(my_data)\ndistances = dmy_sssp!(graph, source)","category":"page"},{"location":"manual/transformation/#Domain-Agnostic-Examples","page":"Problem Transformation","title":"Domain-Agnostic Examples","text":"","category":"section"},{"location":"manual/transformation/#Resource-Scheduling","page":"Problem Transformation","title":"Resource Scheduling","text":"","category":"section"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"# States: Time slots (1-24) × Resources (A, B, C)\n# Edges: Task assignments\n# Weights: Completion time + setup cost\n\nn_time_slots = 24\nn_resources = 3\nn_vertices = n_time_slots * n_resources\n\n# Create edges for valid task assignments\nedges = Edge[]\nweights = Float64[]\n\nfor t in 1:(n_time_slots-1)\n    for r1 in 1:n_resources\n        for r2 in 1:n_resources\n            from_vertex = (t-1)*n_resources + r1\n            to_vertex = t*n_resources + r2\n\n            completion_time = 1.0\n            setup_cost = r1 == r2 ? 0.0 : 2.0  # Penalty for resource change\n\n            push!(edges, Edge(from_vertex, to_vertex, length(edges)+1))\n            push!(weights, completion_time + setup_cost)\n        end\n    end\nend\n\ngraph = DMYGraph(n_vertices, edges, weights)","category":"page"},{"location":"manual/transformation/#Network-Flow","page":"Problem Transformation","title":"Network Flow","text":"","category":"section"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"# States: Network nodes\n# Edges: Links with capacity constraints\n# Weights: Latency + congestion cost\n\n# Transform max-flow to shortest path by:\n# 1. Invert capacity: weight = 1/capacity\n# 2. Add congestion penalty\n# 3. Find min-cost path\n\nfunction capacity_to_weight(capacity, current_flow)\n    congestion = current_flow / capacity\n    return 1/capacity + 10.0 * congestion^2\nend","category":"page"},{"location":"manual/transformation/#Key-Constraints","page":"Problem Transformation","title":"Key Constraints","text":"","category":"section"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"warning: Non-Negative Weights Required\nThe DMY algorithm requires all edge weights ≥ 0. Transform maximization objectives:Revenue → Cost: weight = -revenue + baseline\nProbability → Distance: weight = -log(probability)\nSimilarity → Distance: weight = 1 - similarity","category":"page"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"info: Directed Graphs Only\nAll graphs must be directed. For undirected graphs, add edges in both directions.","category":"page"},{"location":"manual/transformation/#See-Also","page":"Problem Transformation","title":"See Also","text":"","category":"section"},{"location":"manual/transformation/","page":"Problem Transformation","title":"Problem Transformation","text":"Multi-Objective Optimization for handling multiple objectives\nDomain Applications for pre-built transformation helpers\nAPI Reference for complete function documentation","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Complete reference for all exported functions and types in OptimShortestPaths.","category":"page"},{"location":"api/#Core-Algorithm","page":"API Reference","title":"Core Algorithm","text":"","category":"section"},{"location":"api/#Main-Functions","page":"API Reference","title":"Main Functions","text":"","category":"section"},{"location":"api/#OptimShortestPaths.dmy_sssp!","page":"API Reference","title":"OptimShortestPaths.dmy_sssp!","text":"dmy_sssp!(graph::DMYGraph, source::Int) -> Vector{Float64}\n\nMain entry point for the DMY shortest-path algorithm. Computes single-source shortest paths from the given source vertex.\n\nArguments\n\ngraph: The directed graph with non-negative edge weights\nsource: Source vertex index (1-based)\n\nReturns\n\nVector of shortest distances from source to all vertices\n\nAlgorithm Overview\n\nThe DMY algorithm uses recursive layering with frontier sparsification:\n\nInitialize distance and parent arrays\nCall recursive_layer! with full vertex set\nReturn computed distances\n\nTime complexity: O(m log^(2/3) n) for sparse graphs Space complexity: O(n) for distance and parent arrays\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.dmy_sssp_with_parents!","page":"API Reference","title":"OptimShortestPaths.dmy_sssp_with_parents!","text":"dmy_sssp_with_parents!(graph::DMYGraph, source::Int) -> Tuple{Vector{Float64}, Vector{Int}}\n\nDMY algorithm that returns both distances and parent pointers for path reconstruction.\n\nReturns\n\nTuple of (distances, parents) where parents[v] gives the predecessor of v in shortest path tree\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.dmy_sssp_bounded!","page":"API Reference","title":"OptimShortestPaths.dmy_sssp_bounded!","text":"dmy_sssp_bounded!(graph::DMYGraph, source::Int, max_distance::Float64) -> Vector{Float64}\n\nDMY algorithm with distance bound - only computes paths up to max_distance. Can be more efficient when only short paths are needed.\n\nArguments\n\ngraph: The directed graph\nsource: Source vertex\nmax_distance: Maximum distance to compute (paths longer than this are ignored)\n\nReturns\n\nDistance array with INF for vertices beyond max_distance\n\n\n\n\n\n","category":"function"},{"location":"api/#Graph-Types","page":"API Reference","title":"Graph Types","text":"","category":"section"},{"location":"api/#OptimShortestPaths.DMYGraph","page":"API Reference","title":"OptimShortestPaths.DMYGraph","text":"DMYGraph\n\nEfficient graph representation for the DMY algorithm using adjacency lists. Stores vertices, edges, and weights with validation for non-negative weights.\n\n\n\n\n\n","category":"type"},{"location":"api/#OptimShortestPaths.Edge","page":"API Reference","title":"OptimShortestPaths.Edge","text":"Edge\n\nRepresents a directed edge in the graph with source, target vertices and weight index.\n\n\n\n\n\n","category":"type"},{"location":"api/#OptimShortestPaths.Block","page":"API Reference","title":"OptimShortestPaths.Block","text":"Block\n\nRepresents a partitioned block of vertices for recursive processing.\n\n\n\n\n\n","category":"type"},{"location":"api/#Algorithm-Components","page":"API Reference","title":"Algorithm Components","text":"","category":"section"},{"location":"api/#OptimShortestPaths.recursive_layer!","page":"API Reference","title":"OptimShortestPaths.recursive_layer!","text":"recursive_layer!(graph::DMYGraph, dist::Vector{Float64}, parent::Vector{Int},\n                U::Vector{Int}, S::OrderedSet{Int}, B::Float64) -> Nothing\n\nRecursive layer processing function that implements the core DMY algorithm logic. Processes vertex subset U with current frontier S and upper bound B.\n\nArguments\n\ngraph: The graph to process\ndist: Distance array (modified in-place)\nparent: Parent array for path reconstruction (modified in-place)\nU: Vertex subset to process\nS: Current frontier set\nB: Upper bound for distance updates\n\nThe function implements the recursive layering strategy with:\n\nBase case handling for small vertex sets\nPivot threshold calculation k = ⌈|U|^(1/3)⌉\nFrontier size checking and algorithm path selection\nPivot selection for frontier sparsification when needed\nVertex partitioning and recursive calls\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.bmssp!","page":"API Reference","title":"OptimShortestPaths.bmssp!","text":"bmssp!(graph::DMYGraph, dist::Vector{Float64}, parent::Vector{Int},\n       frontier::AbstractSet{Int}, bound::Float64, k::Int) -> OrderedSet{Int}\n\nPerform bounded multi-source shortest path relaxation for k rounds. Updates the distance and parent arrays in-place and returns the final frontier.\n\nArguments\n\ngraph: The graph to process\ndist: Distance array (modified in-place)\nparent: Parent array for path reconstruction (modified in-place)\nfrontier: Set of active vertices for relaxation\nbound: Upper bound for distance updates\nk: Maximum number of relaxation rounds\n\nReturns\n\nFinal frontier set after k rounds or early termination\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.bmssp_single_round!","page":"API Reference","title":"OptimShortestPaths.bmssp_single_round!","text":"bmssp_single_round!(graph::DMYGraph, dist::Vector{Float64}, parent::Vector{Int},\n                    frontier::AbstractSet{Int}, bound::Float64) -> Tuple{OrderedSet{Int}, Bool}\n\nPerform a single round of BMSSP relaxation. Returns the new frontier and whether any updates occurred.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.select_pivots","page":"API Reference","title":"OptimShortestPaths.select_pivots","text":"select_pivots(U_tilde::Vector{Int}, S::AbstractSet{Int}, k::Int, dist::Vector{Float64}) -> Vector{Int}\n\nSelect pivot vertices from U_tilde to sparsify the frontier. Uses distance-based clustering to choose representative vertices.\n\nArguments\n\nU_tilde: Filtered vertex set (vertices not in S with finite distance < bound)\nS: Current frontier set\nk: Pivot threshold (typically ⌈|U|^(1/3)⌉)\ndist: Current distance array\n\nReturns\n\nVector of selected pivot vertices with |P| ≤ |U_tilde| / k\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.partition_blocks","page":"API Reference","title":"OptimShortestPaths.partition_blocks","text":"partition_blocks(U::Vector{Int}, dist::Vector{Float64}, t::Int, B::Float64=INF) -> Vector{Block}\n\nPartition vertex set U into 2^t nearly equal blocks based on distance values. Each block gets a frontier seed and upper bound for recursive processing.\n\nArguments\n\nU: Vertex set to partition\ndist: Distance array\nt: Partition parameter (typically ⌈log^(1/3) n⌉)\nB: Overall bound for distances (default: INF)\n\nReturns\n\nVector of Block objects with vertices, frontier, and upper bound\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.partition_blocks_adaptive","page":"API Reference","title":"OptimShortestPaths.partition_blocks_adaptive","text":"partition_blocks_adaptive(U::Vector{Int}, dist::Vector{Float64}, t::Int, \n                         graph::DMYGraph, B::Float64=INF) -> Vector{Block}\n\nAdaptive block partitioning that considers graph structure and distance distribution. Creates more balanced blocks based on both distance and connectivity.\n\n\n\n\n\n","category":"function"},{"location":"api/#Validation","page":"API Reference","title":"Validation","text":"","category":"section"},{"location":"api/#OptimShortestPaths.validate_bmssp_input","page":"API Reference","title":"OptimShortestPaths.validate_bmssp_input","text":"validate_bmssp_input(graph::DMYGraph, dist::Vector{Float64}, parent::Vector{Int},\n                    frontier::AbstractSet{Int}, bound::Float64, k::Int) -> Bool\n\nValidate inputs for BMSSP function. Throws ArgumentError if invalid.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.validate_dmy_input","page":"API Reference","title":"OptimShortestPaths.validate_dmy_input","text":"validate_dmy_input(graph::DMYGraph, source::Int) -> Bool\n\nValidate inputs for DMY algorithm. Throws appropriate errors if invalid.\n\n\n\n\n\n","category":"function"},{"location":"api/#Statistics","page":"API Reference","title":"Statistics","text":"","category":"section"},{"location":"api/#OptimShortestPaths.bmssp_with_statistics!","page":"API Reference","title":"OptimShortestPaths.bmssp_with_statistics!","text":"bmssp_with_statistics!(graph::DMYGraph, dist::Vector{Float64}, parent::Vector{Int},\n                      frontier::AbstractSet{Int}, bound::Float64, k::Int) -> Dict{String, Any}\n\nPerform BMSSP with detailed statistics collection. Returns statistics about the relaxation process.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.dmy_algorithm_statistics","page":"API Reference","title":"OptimShortestPaths.dmy_algorithm_statistics","text":"dmy_algorithm_statistics(graph::DMYGraph, source::Int) -> Dict{String, Any}\n\nRun DMY algorithm with detailed statistics collection. Useful for algorithm analysis and performance tuning.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.count_relaxations","page":"API Reference","title":"OptimShortestPaths.count_relaxations","text":"count_relaxations(graph::DMYGraph, frontier::AbstractSet{Int}, bound::Float64, \n                 dist::Vector{Float64}) -> Int\n\nCount the number of edge relaxations that would be performed in the next round. Useful for algorithm analysis and debugging.\n\n\n\n\n\n","category":"function"},{"location":"api/#Multi-Objective-Optimization","page":"API Reference","title":"Multi-Objective Optimization","text":"","category":"section"},{"location":"api/#Main-Functions-2","page":"API Reference","title":"Main Functions","text":"","category":"section"},{"location":"api/#OptimShortestPaths.MultiObjective.compute_pareto_front","page":"API Reference","title":"OptimShortestPaths.MultiObjective.compute_pareto_front","text":"Compute the full Pareto front for multi-objective shortest paths. Returns all non-dominated paths from source to target.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.MultiObjective.get_knee_point","page":"API Reference","title":"OptimShortestPaths.MultiObjective.get_knee_point","text":"Find the \"knee point\" in the Pareto front - the solution with best trade-off. Uses the maximum distance from the utopia-nadir line.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.MultiObjective.compute_path_objectives","page":"API Reference","title":"OptimShortestPaths.MultiObjective.compute_path_objectives","text":"Compute objective values for a path given parent array. Optionally accepts a vector of edge indices (per vertex) that identifies which multi-objective edge was used to reach each vertex.\n\n\n\n\n\n","category":"function"},{"location":"api/#Optimization-Methods","page":"API Reference","title":"Optimization Methods","text":"","category":"section"},{"location":"api/#OptimShortestPaths.MultiObjective.weighted_sum_approach","page":"API Reference","title":"OptimShortestPaths.MultiObjective.weighted_sum_approach","text":"Weighted sum approach: Combine objectives with weights. Simple but may miss some Pareto-optimal solutions.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.MultiObjective.epsilon_constraint_approach","page":"API Reference","title":"OptimShortestPaths.MultiObjective.epsilon_constraint_approach","text":"Epsilon-constraint approach: Optimize one objective while constraining others. Good for finding specific trade-off solutions.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.MultiObjective.lexicographic_approach","page":"API Reference","title":"OptimShortestPaths.MultiObjective.lexicographic_approach","text":"Lexicographic approach: Optimize objectives in priority order. Good when objectives have clear priority ranking.\n\n\n\n\n\n","category":"function"},{"location":"api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/#OptimShortestPaths.MultiObjective.ParetoSolution","page":"API Reference","title":"OptimShortestPaths.MultiObjective.ParetoSolution","text":"A Pareto-optimal solution with multiple objective values\n\n\n\n\n\n","category":"type"},{"location":"api/#OptimShortestPaths.MultiObjective.MultiObjectiveGraph","page":"API Reference","title":"OptimShortestPaths.MultiObjective.MultiObjectiveGraph","text":"Multi-objective graph structure\n\n\n\n\n\n","category":"type"},{"location":"api/#OptimShortestPaths.MultiObjective.MultiObjectiveEdge","page":"API Reference","title":"OptimShortestPaths.MultiObjective.MultiObjectiveEdge","text":"Edge with multiple objective weights (e.g., distance, cost, risk, time)\n\n\n\n\n\n","category":"type"},{"location":"api/#Problem-Transformation","page":"API Reference","title":"Problem Transformation","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"The core innovation of OptimShortestPaths - transforming optimization problems into graphs.","category":"page"},{"location":"api/#OptimShortestPaths.OptimizationProblem","page":"API Reference","title":"OptimShortestPaths.OptimizationProblem","text":"OptimizationProblem(::Symbol, data, source)\n\nContainer for problem instances that can be transformed into a graph using the OptimShortestPaths casting helpers. data is the argument tuple that will be splatted into the corresponding constructor (e.g. create_drug_target_network).\n\n\n\n\n\n","category":"type"},{"location":"api/#OptimShortestPaths.optimize_to_graph","page":"API Reference","title":"OptimShortestPaths.optimize_to_graph","text":"Main OptimShortestPaths interface: optimize by casting to shortest path.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.cast_problem","page":"API Reference","title":"OptimShortestPaths.cast_problem","text":"Cast an optimization problem to a graph representation. This is the core innovation of OptimShortestPaths: transforming optimization into shortest paths.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.objectives_to_weights","page":"API Reference","title":"OptimShortestPaths.objectives_to_weights","text":"Transform optimization objectives into edge weights.\n\n\n\n\n\n","category":"function"},{"location":"api/#Domain-Specific-Applications","page":"API Reference","title":"Domain-Specific Applications","text":"","category":"section"},{"location":"api/#Pharmaceutical-Networks","page":"API Reference","title":"Pharmaceutical Networks","text":"","category":"section"},{"location":"api/#Types-2","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/#OptimShortestPaths.PharmaNetwork","page":"API Reference","title":"OptimShortestPaths.PharmaNetwork","text":"PharmaNetwork\n\nAbstract base type for pharmaceutical network representations.\n\n\n\n\n\n","category":"type"},{"location":"api/#OptimShortestPaths.DrugTargetNetwork","page":"API Reference","title":"OptimShortestPaths.DrugTargetNetwork","text":"DrugTargetNetwork <: PharmaNetwork\n\nRepresents drug-target interaction networks for pharmaceutical applications.\n\n\n\n\n\n","category":"type"},{"location":"api/#OptimShortestPaths.MetabolicPathway","page":"API Reference","title":"OptimShortestPaths.MetabolicPathway","text":"MetabolicPathway <: PharmaNetwork\n\nRepresents metabolic pathway networks with metabolites and enzymatic reactions.\n\n\n\n\n\n","category":"type"},{"location":"api/#OptimShortestPaths.TreatmentProtocol","page":"API Reference","title":"OptimShortestPaths.TreatmentProtocol","text":"TreatmentProtocol <: PharmaNetwork\n\nRepresents treatment protocol networks with treatment steps and transition costs.\n\n\n\n\n\n","category":"type"},{"location":"api/#Constructors","page":"API Reference","title":"Constructors","text":"","category":"section"},{"location":"api/#OptimShortestPaths.Pharma.create_drug_target_network","page":"API Reference","title":"OptimShortestPaths.Pharma.create_drug_target_network","text":"create_drug_target_network(drugs::Vector{String}, targets::Vector{String}, \n                          interactions::Matrix{Float64}) -> DrugTargetNetwork\n\nCreate a drug-target interaction network from drug names, target names, and interaction matrix. The interaction matrix contains binding affinities or interaction strengths.\n\nArguments\n\ndrugs: Vector of drug names\ntargets: Vector of target protein names  \ninteractions: Matrix where interactions[i,j] is the binding affinity between drug i and target j                Use 0.0 for no interaction, positive values for binding affinities\n\nReturns\n\nDrugTargetNetwork with underlying graph representation\n\nNetwork Structure\n\nVertices represent both drugs and targets\nEdges represent drug-target interactions\nEdge weights are -log(binding_affinity) to convert to distance metric\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.Pharma.create_metabolic_pathway","page":"API Reference","title":"OptimShortestPaths.Pharma.create_metabolic_pathway","text":"create_metabolic_pathway(metabolites::Vector{String}, reactions::Vector{String}, \n                       reaction_costs::Vector{Float64}, \n                       reaction_network::Vector{Tuple{String, String, String}}) -> MetabolicPathway\n\nCreate a metabolic pathway network from metabolites, reactions, and their connections.\n\nArguments\n\nmetabolites: Vector of metabolite names\nreactions: Vector of reaction names\nreaction_costs: Vector of costs for each reaction (energy, time, etc.)\nreaction_network: Vector of (substrate, reaction, product) tuples defining the pathway\n\nReturns\n\nMetabolicPathway with underlying graph representation\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.Pharma.create_treatment_protocol","page":"API Reference","title":"OptimShortestPaths.Pharma.create_treatment_protocol","text":"create_treatment_protocol(treatments::Vector{String}, costs::Vector{Float64}, \n                        efficacy_weights::Vector{Float64}, \n                        transitions::Vector{Tuple{String, String, Float64}}) -> TreatmentProtocol\n\nCreate a treatment protocol network for healthcare optimization.\n\nArguments\n\ntreatments: Vector of treatment step names\ncosts: Vector of costs for each treatment\nefficacy_weights: Vector of efficacy weights for each treatment\ntransitions: Vector of (fromtreatment, totreatment, transition_cost) tuples\n\nReturns\n\nTreatmentProtocol with underlying graph representation\n\n\n\n\n\n","category":"function"},{"location":"api/#Analysis-Functions","page":"API Reference","title":"Analysis Functions","text":"","category":"section"},{"location":"api/#OptimShortestPaths.Pharma.find_drug_target_paths","page":"API Reference","title":"OptimShortestPaths.Pharma.find_drug_target_paths","text":"find_drug_target_paths(network::DrugTargetNetwork, drug_name::String, \n                      target_name::String) -> Tuple{Float64, Vector{String}}\n\nFind the shortest path from a drug to a target in the network. Returns the path distance and the sequence of drugs/targets in the path.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.Pharma.analyze_drug_connectivity","page":"API Reference","title":"OptimShortestPaths.Pharma.analyze_drug_connectivity","text":"analyze_drug_connectivity(network::DrugTargetNetwork, drug_name::String) -> Dict{String, Any}\n\nAnalyze the connectivity of a specific drug in the network. Returns statistics about reachable targets and path lengths.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.Pharma.find_metabolic_pathway","page":"API Reference","title":"OptimShortestPaths.Pharma.find_metabolic_pathway","text":"find_metabolic_pathway(pathway::MetabolicPathway, start_metabolite::String, \n                      end_metabolite::String) -> Tuple{Float64, Vector{String}}\n\nFind the shortest metabolic pathway between two metabolites. Returns the total cost and sequence of metabolites in the pathway.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.Pharma.optimize_treatment_sequence","page":"API Reference","title":"OptimShortestPaths.Pharma.optimize_treatment_sequence","text":"optimize_treatment_sequence(protocol::TreatmentProtocol, start_treatment::String, \n                           end_treatment::String) -> Tuple{Float64, Vector{String}}\n\nFind the optimal treatment sequence from start to end treatment. Returns the total cost and sequence of treatments.\n\n\n\n\n\n","category":"function"},{"location":"api/#Generic-Graph-Utilities","page":"API Reference","title":"Generic Graph Utilities","text":"","category":"section"},{"location":"api/#Path-Operations","page":"API Reference","title":"Path Operations","text":"","category":"section"},{"location":"api/#OptimShortestPaths.find_shortest_path","page":"API Reference","title":"OptimShortestPaths.find_shortest_path","text":"find_shortest_path(graph::DMYGraph, source::Int, target::Int)\n\nFind the shortest path and distance between two vertices.\n\nReturns\n\nTuple of (distance, path) where path is vector of vertex indices\n\nExample\n\ndistance, path = find_shortest_path(graph, start, goal)\nif distance < INF\n    println(\"Path found: \", join(path, \" -> \"))\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.reconstruct_path","page":"API Reference","title":"OptimShortestPaths.reconstruct_path","text":"reconstruct_path(parent::Vector{Int}, source::Int, target::Int) -> Vector{Int}\n\nReconstruct the shortest path from source to target using parent pointers. Returns empty vector if no path exists.\n\nArguments\n\nparent: Parent array from DMY algorithm\nsource: Source vertex\ntarget: Target vertex\n\nReturns\n\nVector of vertices representing the path from source to target\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.shortest_path_tree","page":"API Reference","title":"OptimShortestPaths.shortest_path_tree","text":"shortest_path_tree(parent::Vector{Int}, source::Int) -> Dict{Int, Vector{Int}}\n\nConstruct the complete shortest path tree from the parent array. Returns a dictionary mapping each reachable vertex to its path from source.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.path_length","page":"API Reference","title":"OptimShortestPaths.path_length","text":"path_length(path::Vector{Int}, graph::DMYGraph) -> Float64\n\nCalculate the total length of a path in the graph. Returns INF if path is invalid or contains non-existent edges.\n\n\n\n\n\n","category":"function"},{"location":"api/#Connectivity-Analysis","page":"API Reference","title":"Connectivity Analysis","text":"","category":"section"},{"location":"api/#OptimShortestPaths.analyze_connectivity","page":"API Reference","title":"OptimShortestPaths.analyze_connectivity","text":"analyze_connectivity(graph::DMYGraph, source::Int)\n\nAnalyze connectivity metrics from a source vertex.\n\nReturns\n\nDictionary containing:\n\nreachable_count: Number of reachable vertices\nunreachable_count: Number of unreachable vertices  \navg_distance: Average distance to reachable vertices\nmax_distance: Maximum finite distance\nconnectivity_ratio: Fraction of vertices that are reachable\n\nExample\n\nmetrics = analyze_connectivity(graph, hub_vertex)\nprintln(\"Hub connectivity: \", metrics[\"connectivity_ratio\"] * 100, \"%\")\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.find_reachable_vertices","page":"API Reference","title":"OptimShortestPaths.find_reachable_vertices","text":"find_reachable_vertices(graph::DMYGraph, source::Int, max_distance::Float64 = INF)\n\nFind all vertices reachable from source within a maximum distance.\n\nArguments\n\ngraph: The graph to analyze\nsource: Source vertex\nmax_distance: Maximum distance threshold (default: INF for all reachable)\n\nReturns\n\nVector of vertex indices that are reachable within max_distance\n\nExample\n\n# Find all vertices within distance 10 from source\nnearby = find_reachable_vertices(graph, source, 10.0)\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.graph_reachability","page":"API Reference","title":"OptimShortestPaths.graph_reachability","text":"graph_reachability(graph::DMYGraph, source::Int) -> Set{Int}\n\nFind all vertices reachable from the source vertex. Uses simple BFS traversal.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.is_connected","page":"API Reference","title":"OptimShortestPaths.is_connected","text":"is_connected(graph::DMYGraph, source::Int, target::Int) -> Bool\n\nCheck if there is a direct edge from source to target vertex.\n\n\n\n\n\n","category":"function"},{"location":"api/#Distance-Metrics","page":"API Reference","title":"Distance Metrics","text":"","category":"section"},{"location":"api/#OptimShortestPaths.calculate_distance_ratio","page":"API Reference","title":"OptimShortestPaths.calculate_distance_ratio","text":"calculate_distance_ratio(graph::DMYGraph, source::Int, target1::Int, target2::Int)\n\nCalculate the ratio of distances from source to two different targets. This is a generic function useful for selectivity, preference, or comparison metrics.\n\nArguments\n\ngraph: The graph to analyze\nsource: Source vertex\ntarget1: First target vertex (numerator in ratio)\ntarget2: Second target vertex (denominator in ratio)\n\nReturns\n\nRatio of distance to target1 / distance to target2\nReturns 0.0 if either distance is 0 or unreachable\nReturns Inf if target2 is unreachable but target1 is reachable\n\nExample\n\n# For drug selectivity: higher ratio means more selective for target2\nratio = calculate_distance_ratio(graph, drug_vertex, cox1_vertex, cox2_vertex)\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.calculate_path_preference","page":"API Reference","title":"OptimShortestPaths.calculate_path_preference","text":"calculate_path_preference(graph::DMYGraph, source::Int, preferred::Int, alternative::Int)\n\nCalculate preference score for reaching one target over another from a source. Higher values indicate stronger preference for the preferred target.\n\nArguments\n\ngraph: The graph to analyze\nsource: Source vertex\npreferred: Preferred target vertex\nalternative: Alternative target vertex\n\nReturns\n\nPreference score (higher is better for preferred target)\nUses inverse distance ratio so lower distance = higher preference\n\nExample\n\n# Check if pathway A is preferred over pathway B\npreference = calculate_path_preference(graph, start, pathwayA, pathwayB)\nif preference > 1.5\n    println(\"Strong preference for pathway A\")\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.compare_sources","page":"API Reference","title":"OptimShortestPaths.compare_sources","text":"compare_sources(graph::DMYGraph, sources::Vector{Int}, target::Int)\n\nCompare distances from multiple sources to a single target.\n\nArguments\n\ngraph: The graph to analyze\nsources: Vector of source vertices to compare\ntarget: Target vertex\n\nReturns\n\nDictionary mapping source vertex to distance to target\n\nExample\n\n# Compare which warehouse is closest to customer\nwarehouses = [1, 2, 3]\ncustomer = 10\ndistances = compare_sources(graph, warehouses, customer)\nbest_warehouse = argmin(distances)\n\n\n\n\n\n","category":"function"},{"location":"api/#Graph-Properties","page":"API Reference","title":"Graph Properties","text":"","category":"section"},{"location":"api/#OptimShortestPaths.vertex_count","page":"API Reference","title":"OptimShortestPaths.vertex_count","text":"vertex_count(graph::DMYGraph) -> Int\n\nReturn the number of vertices in the graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.edge_count","page":"API Reference","title":"OptimShortestPaths.edge_count","text":"edge_count(graph::DMYGraph) -> Int\n\nReturn the number of edges in the graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.out_degree","page":"API Reference","title":"OptimShortestPaths.out_degree","text":"out_degree(graph::DMYGraph, vertex::Int) -> Int\n\nReturn the out-degree of the specified vertex.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.outgoing_edges","page":"API Reference","title":"OptimShortestPaths.outgoing_edges","text":"outgoing_edges(graph::DMYGraph, vertex::Int) -> Vector{Int}\n\nReturn the indices of all outgoing edges from the specified vertex.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.graph_density","page":"API Reference","title":"OptimShortestPaths.graph_density","text":"graph_density(graph::DMYGraph) -> Float64\n\nCalculate the density of the graph (ratio of actual edges to possible edges).\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.graph_statistics","page":"API Reference","title":"OptimShortestPaths.graph_statistics","text":"graph_statistics(graph::DMYGraph) -> Dict{String, Any}\n\nReturn comprehensive statistics about the graph structure.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.has_self_loops","page":"API Reference","title":"OptimShortestPaths.has_self_loops","text":"has_self_loops(graph::DMYGraph) -> Bool\n\nCheck if the graph contains any self-loops (edges from a vertex to itself).\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.get_vertices_by_out_degree","page":"API Reference","title":"OptimShortestPaths.get_vertices_by_out_degree","text":"get_vertices_by_out_degree(graph::DMYGraph) -> Vector{Tuple{Int,Int}}\n\nReturn vertices sorted by their out-degree in descending order. Returns vector of (vertex, out_degree) tuples.\n\n\n\n\n\n","category":"function"},{"location":"api/#Edge-Operations","page":"API Reference","title":"Edge Operations","text":"","category":"section"},{"location":"api/#OptimShortestPaths.get_edge","page":"API Reference","title":"OptimShortestPaths.get_edge","text":"get_edge(graph::DMYGraph, edge_index::Int) -> Edge\n\nReturn the edge at the specified index.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.get_edge_weight","page":"API Reference","title":"OptimShortestPaths.get_edge_weight","text":"get_edge_weight(graph::DMYGraph, edge_index::Int) -> Float64\n\nReturn the weight of the edge at the specified index.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.get_edge_weight_between","page":"API Reference","title":"OptimShortestPaths.get_edge_weight_between","text":"get_edge_weight_between(graph::DMYGraph, source::Int, target::Int) -> Union{Float64, Nothing}\n\nGet the weight of the edge from source to target, or return nothing if no edge exists. If multiple edges exist, returns the weight of the first one found.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.find_edge","page":"API Reference","title":"OptimShortestPaths.find_edge","text":"find_edge(graph::DMYGraph, source::Int, target::Int) -> Union{Int, Nothing}\n\nFind the index of the edge from source to target, or return nothing if not found. If multiple edges exist, returns the first one found.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.iterate_edges","page":"API Reference","title":"OptimShortestPaths.iterate_edges","text":"iterate_edges(graph::DMYGraph, vertex::Int)\n\nIterator for outgoing edges from a vertex. Returns (edge, weight) pairs.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.get_all_targets","page":"API Reference","title":"OptimShortestPaths.get_all_targets","text":"get_all_targets(graph::DMYGraph, source::Int) -> Vector{Int}\n\nGet all target vertices reachable directly from the source vertex.\n\n\n\n\n\n","category":"function"},{"location":"api/#Graph-Construction","page":"API Reference","title":"Graph Construction","text":"","category":"section"},{"location":"api/#OptimShortestPaths.create_simple_graph","page":"API Reference","title":"OptimShortestPaths.create_simple_graph","text":"create_simple_graph(n_vertices::Int, edge_list::Vector{Tuple{Int,Int,Float64}}) -> DMYGraph\n\nCreate a DMYGraph from a simple edge list representation. Each tuple contains (source, target, weight).\n\n\n\n\n\n","category":"function"},{"location":"api/#Validation-and-Verification","page":"API Reference","title":"Validation & Verification","text":"","category":"section"},{"location":"api/#OptimShortestPaths.validate_graph","page":"API Reference","title":"OptimShortestPaths.validate_graph","text":"validate_graph(graph::DMYGraph) -> Bool\n\nValidate the structure and properties of a DMYGraph. Returns true if valid, throws ArgumentError if invalid.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.validate_vertex","page":"API Reference","title":"OptimShortestPaths.validate_vertex","text":"validate_vertex(graph::DMYGraph, vertex::Int) -> Bool\n\nValidate that a vertex index is within the valid range for the graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.verify_shortest_path","page":"API Reference","title":"OptimShortestPaths.verify_shortest_path","text":"verify_shortest_path(graph::DMYGraph, dist::Vector{Float64}, source::Int, target::Int) -> Bool\n\nVerify that the computed distance is indeed the shortest path length. Useful for debugging and validation.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.format_distance_results","page":"API Reference","title":"OptimShortestPaths.format_distance_results","text":"format_distance_results(dist::Vector{Float64}, source::Int) -> String\n\nFormat distance results for human-readable output.\n\n\n\n\n\n","category":"function"},{"location":"api/#Comparison-and-Benchmarking","page":"API Reference","title":"Comparison & Benchmarking","text":"","category":"section"},{"location":"api/#OptimShortestPaths.compare_with_dijkstra","page":"API Reference","title":"OptimShortestPaths.compare_with_dijkstra","text":"compare_with_dijkstra(graph::DMYGraph, source::Int) -> Dict{String, Any}\n\nCompare DMY algorithm results with Dijkstra's algorithm for validation. Returns comparison statistics and identifies any discrepancies.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.simple_dijkstra","page":"API Reference","title":"OptimShortestPaths.simple_dijkstra","text":"simple_dijkstra(graph::DMYGraph, source::Int) -> Vector{Float64}\n\nSimple Dijkstra's algorithm implementation for comparison and validation. Not optimized for performance - used only for correctness checking.\n\n\n\n\n\n","category":"function"},{"location":"api/#Advanced-Functions","page":"API Reference","title":"Advanced Functions","text":"","category":"section"},{"location":"api/#Pivot-Selection","page":"API Reference","title":"Pivot Selection","text":"","category":"section"},{"location":"api/#OptimShortestPaths.calculate_pivot_threshold","page":"API Reference","title":"OptimShortestPaths.calculate_pivot_threshold","text":"calculate_pivot_threshold(U_size::Int) -> Int\n\nCalculate the pivot threshold k = ⌈|U|^(1/3)⌉ for a given vertex set size. This is the theoretical optimum from the DMY paper.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.calculate_partition_parameter","page":"API Reference","title":"OptimShortestPaths.calculate_partition_parameter","text":"calculate_partition_parameter(n::Int) -> Int\n\nCalculate the partition parameter t = ⌈log^(1/3) n⌉ for a given graph size. This determines the number of blocks (2^t) in recursive partitioning.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.pivot_selection_statistics","page":"API Reference","title":"OptimShortestPaths.pivot_selection_statistics","text":"pivot_selection_statistics(U_tilde::Vector{Int}, S::AbstractSet{Int}, k::Int,\n                          pivots::Vector{Int}, dist::Vector{Float64}) -> Dict{String, Any}\n\nCollect statistics about the pivot selection process.\n\n\n\n\n\n","category":"function"},{"location":"api/#OptimShortestPaths.validate_pivot_selection","page":"API Reference","title":"OptimShortestPaths.validate_pivot_selection","text":"validate_pivot_selection(pivots::Vector{Int}, U_tilde::Vector{Int}, k::Int) -> Bool\n\nValidate that pivot selection satisfies the algorithm constraints. Checks that |P| ≤ |Utilde| / k and all pivots are from Utilde.\n\n\n\n\n\n","category":"function"},{"location":"api/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"examples/treatment_protocol/","page":"Treatment Protocols","title":"Treatment Protocols","text":"begin\n    using Markdown\n    dashboard_path = joinpath(dirname(dirname(dirname(@__DIR__))), \"examples\", \"treatment_protocol\", \"DASHBOARD.md\")\n    Markdown.parse(read(dashboard_path, String))\nend","category":"page"},{"location":"examples/supply_chain/","page":"Supply Chain Optimization","title":"Supply Chain Optimization","text":"begin\n    using Markdown\n    dashboard_path = joinpath(dirname(dirname(dirname(@__DIR__))), \"examples\", \"supply_chain\", \"DASHBOARD.md\")\n    Markdown.parse(read(dashboard_path, String))\nend","category":"page"},{"location":"examples/metabolic_pathway/","page":"Metabolic Pathways","title":"Metabolic Pathways","text":"begin\n    using Markdown\n    dashboard_path = joinpath(dirname(dirname(dirname(@__DIR__))), \"examples\", \"metabolic_pathway\", \"DASHBOARD.md\")\n    Markdown.parse(read(dashboard_path, String))\nend","category":"page"},{"location":"cheatsheet/#OptimShortestPaths.jl-Cheat-Sheet","page":"Cheat Sheet","title":"OptimShortestPaths.jl Cheat Sheet","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"A practical, example-driven guide to the most commonly used functions. It starts from single-source shortest paths, builds up through utilities and bounded variants, covers multi-objective methods, and ends with domain-specific pharma helpers. Each example includes detailed explanation so you understand the variables, setup, and rationale.","category":"page"},{"location":"cheatsheet/#Table-of-Contents","page":"Cheat Sheet","title":"Table of Contents","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Quick Start\nCore Shortest Path\nPath Helpers\nGraph Utilities\nAnalysis & Comparison\nBounded & Internals (Advanced)\nPreference & Connectivity\nMulti-Objective Shortest Paths (MOSP)\nPharma Conveniences (Domain Wrappers)\nEnd-to-End Example: Generic Graph Walkthrough\nComprehensive Function Reference (Cheat Sheet Tables)\nDetailed Output Keys (Analysis Functions)\nConstraints & Assumptions Cheatsheet\nTypical Pitfalls & Remedies\nComplexity Snapshot","category":"page"},{"location":"cheatsheet/#Quick-Start","page":"Cheat Sheet","title":"Quick Start","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Load the package from the repo root:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"include(\"src/OptimShortestPaths.jl\"); using .OptimShortestPaths  # load local module file and bring exported APIs into scope","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Explanation:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"include(\"src/OptimShortestPaths.jl\") loads the module file directly from the source path so you can use it without installing a package.\nusing .OptimShortestPaths brings the module’s exported functions and types into the current namespace; the leading dot (.) means “use the module defined in this local file”.\nAfter this, you can call constructors like Edge, DMYGraph, and algorithms like dmy_sssp!.","category":"page"},{"location":"cheatsheet/#Core-Shortest-Path","page":"Cheat Sheet","title":"Core Shortest Path","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"DMYGraph(n_vertices, edges, weights): Create a directed graph.\ndmy_sssp!(graph, source): Single-source shortest path distances.\ndmy_sssp_with_parents!(graph, source): Distances + parent array for paths.\nfind_shortest_path(graph, source, target): Returns (distance, path).","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Example:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Problem Statement:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Goal: Compute single-source shortest paths minimizing the sum of non-negative edge weights.\nInput: Directed graph DMYGraph with aligned edges and weights, source vertex 1.\nOutput: Distance vector from 1 to all vertices and the shortest path from 1 to target 4.\nAssumptions: All weights ≥ 0; vertices are 1..n; edges[i].index == i to align with weights[i].\nRationale: Use DMY for efficient SSSP on sparse graphs and parent pointers to reconstruct paths.","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"# 1) Build a simple directed graph (each line includes why)\nedges   = [\n    Edge(1, 2, 1),  # edge from 1->2; index=1 must equal position 1 so weights[1] maps here\n    Edge(2, 3, 2),  # edge from 2->3; index=2 aligns with position 2 and weights[2]\n    Edge(1, 3, 3),  # edge from 1->3; index=3 aligns with position 3 and weights[3]\n    Edge(3, 4, 4),  # edge from 3->4; index=4 aligns with position 4 and weights[4]\n]\nweights = [\n    1.0,  # cost of edge[1] (1->2); non-negative for DMY requirements\n    1.0,  # cost of edge[2] (2->3);\n    3.0,  # cost of edge[3] (1->3);\n    2.0,  # cost of edge[4] (3->4);\n]\ngraph   = DMYGraph(4, edges, weights)  # constructs adjacency lists and validates index/weight alignment\n\n# 2) Compute distances\ndist = dmy_sssp!(graph, 1)  # run DMY from source=1; dist[v] is shortest distance or INF if unreachable\n\n# 3) Distances + parents, and a path query\n(dist2, parent) = dmy_sssp_with_parents!(graph, 1)  # also returns parent[v] to reconstruct paths\n(distance, path) = find_shortest_path(graph, 1, 4)  # convenience: returns (distance, vertex path)","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Explanation:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"edges: A vector of Edge structs; each edge has (source, target, index) where index must match its position to align with weights.\nweights: A vector of non-negative floats; weights[i] is the cost of edges[i]. Non-negative weights are required for DMY.\ngraph = DMYGraph(4, edges, weights): Builds the adjacency list internally, validates indices, and ensures lengths match.\ndist = dmy_sssp!(graph, 1): Runs the DMY single-source shortest path from vertex 1; returns a distance vector where dist[v] is the shortest distance from 1 to v or INF if unreachable.\ndmy_sssp_with_parents!: Same as above but also returns parent pointers for path reconstruction.\nfind_shortest_path(graph, 1, 4): Helper that internally uses the parents to reconstruct and return the (distance, path) from 1 to 4.","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Note: Edge Index and Weights Alignment (Why and How)","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"What index means: it’s the 1-based ID of an edge and must equal the edge’s position in graph.edges. So edges[i].index == i is required.\nWhy this setup: adjacency lists store edge IDs (integers), not weights or neighbor tuples. During relaxation, the algorithm fetches both the edge and its weight via the same ID for O(1) aligned access:\nedge = graph.edges[edge_idx] and weight = graph.weights[edge_idx] where edge_idx comes from graph.adjacency_list[u].\nInvariants ensured by DMYGraph constructor:\nlength(weights) == length(edges); every edge has exactly one weight.\nedges[i].index == i; keeps edges and weights synchronized.\ngraph.adjacency_list[u] contains valid edge indices and the edge’s source equals u.\nPerformance rationale: separating edges (structs) from weights (plain floats) improves memory locality and numeric operations; the index guarantees a fast, consistent mapping.\nCorrect vs incorrect:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"# Correct: indices match positions\nedges   = [Edge(1,2,1), Edge(1,3,2)]\nweights = [0.5, 1.2]\ngraph   = DMYGraph(3, edges, weights)  # OK\n\n# Incorrect: indices swapped\nedges   = [Edge(1,2,2), Edge(1,3,1)]\nweights = [0.5, 1.2]\ngraph   = DMYGraph(3, edges, weights)  # ERROR: Edge index mismatch at position 1","category":"page"},{"location":"cheatsheet/#Path-Helpers","page":"Cheat Sheet","title":"Path Helpers","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"reconstruct_path(parent, source, target): Rebuild path from parents.\nshortest_path_tree(parent, source): Map each reachable vertex → path.\npath_length(path, graph): Sum weights along the path.\nformat_distance_results(dist, source): Pretty-print distances.","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Example:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Problem Statement:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Goal: Given distances and parent pointers from a DMY run, reconstruct paths for each reachable vertex, verify lengths, and present a human-readable report.\nInput: parent array produced by dmy_sssp_with_parents! and the original graph.\nOutput: Dictionary of vertex → path from source, path lengths, and formatted distance summary.\nRationale: Path reconstruction makes results inspectable and validates that computed distances match edge-weight sums.","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"# Build a shortest-path tree and inspect\ntree = shortest_path_tree(parent, 1)\n@show tree[4]                      # [1, 2, 3, 4]\n@show path_length(tree[4], graph)  # 4.0\n\nprintln(format_distance_results(dist, 1))\n# Shortest distances from vertex 1:\n# ========================================\n# Vertex 1: 0.0\n# Vertex 2: 1.0\n# Vertex 3: 2.0\n# Vertex 4: 4.0\n# ========================================\n# Reachable vertices: 4 / 4","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Explanation:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"shortest_path_tree(parent, 1): Iterates over all vertices, calling reconstruct_path to build the path from source 1; returns a dictionary mapping each reachable vertex to its path.\ntree[4]: Retrieves the path [1, 2, 3, 4] for vertex 4.\npath_length(tree[4], graph): Validates the edges exist and sums their weights; returns INF if any hop is missing.\nformat_distance_results(dist, 1): Produces a readable, line-by-line report, including unreachable vertices and a reachability summary.","category":"page"},{"location":"cheatsheet/#Graph-Utilities","page":"Cheat Sheet","title":"Graph Utilities","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Validation and basics:\nvalidate_graph(graph): Structural checks (indices, sizes, non-negative finite weights).\ncreate_simple_graph(n_vertices, [(u, v, w), ...]): Quick builder.\nvertex_count, edge_count, out_degree, outgoing_edges: Structure stats.\nfind_edge, get_edge_weight_between, is_connected: Edge queries.\nReachability and stats:\ngraph_reachability(graph, source): BFS-style reachability set.\ngraph_statistics(graph): Density, degree extremes, weight stats.","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Example:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Problem Statement:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Goal: Validate graph structural integrity and inspect basic properties before computation.\nInput: A constructed DMYGraph (from the core example) and a simple graph g2 built from tuples.\nOutput: Validation result (or errors), degree counts, reachability set, and structural statistics.\nRationale: Precondition checks ensure algorithm correctness; metrics help understand graph shape and expected performance.","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"validate_graph(graph)                         # throws on invalid structure\n\n# Quick builder\ng2 = create_simple_graph(3, [(1,2,0.5), (2,3,1.0)])\n\n@show out_degree(graph, 1)                    # 2\n@show get_edge_weight_between(graph, 1, 3)    # 3.0\nreachable = graph_reachability(graph, 1)      # Set([1, 2, 3, 4])\nstats = graph_statistics(graph)               # Dict with density/degree/weight stats","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Explanation:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"validate_graph(graph): Ensures the adjacency list matches edges, all weights are finite/non-negative, and indices are consistent.\ncreate_simple_graph(3, ...): Converts tuple input into Edge and weights vectors automatically; useful for quick tests.\nout_degree(graph, 1): Counts outgoing edges for vertex 1.\nget_edge_weight_between(graph, 1, 3): Returns the first matching edge weight or nothing if missing; here 3.0.\ngraph_reachability(graph, 1): Performs a simple BFS ignoring weights to find all vertices reachable from 1.\ngraph_statistics(graph): Reports structural metrics: edge count, density, min/max/avg out-degree, weight statistics.","category":"page"},{"location":"cheatsheet/#Analysis-and-Comparison","page":"Cheat Sheet","title":"Analysis & Comparison","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"verify_shortest_path(graph, dist, source, target): Triangle inequality sanity check.\ncompare_with_dijkstra(graph, source): DMY vs reference Dijkstra.","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Example:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Problem Statement:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Goal: Verify that DMY distances satisfy shortest-path properties and compare against a reference Dijkstra implementation.\nInput: A graph and the distance vector dist computed by DMY from the chosen source.\nOutput: Boolean verification for selected pairs and a comparison dictionary with timing and max difference.\nRationale: Sanity-check correctness; quantify agreement with a known baseline.","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"@assert verify_shortest_path(graph, dist, 1, 4)\ncmp = compare_with_dijkstra(graph, 1)\n@show cmp[\"results_match\"], cmp[\"max_difference\"], cmp[\"speedup\"]","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Explanation:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"verify_shortest_path: Checks that for all u with an edge to target, dist[target] ≤ dist[u] + w(u,target) within tolerance; confirms the computed distance is consistent.\ncompare_with_dijkstra(graph, 1): Runs DMY and a simple Dijkstra, then returns a dictionary with timing and distance differences; results_match should be true and max_difference ~ 0 within float tolerance.\nspeedup: Ratio dijkstra_time / dmy_time; note tiny times can produce noisy ratios, so trust correctness metrics first.","category":"page"},{"location":"cheatsheet/#Bounded-and-Internals-(Advanced)","page":"Cheat Sheet","title":"Bounded & Internals (Advanced)","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"dmy_sssp_bounded!(graph, source, max_distance): Only within distance threshold.\ncalculate_pivot_threshold(U_size): k = ceil(U_size^(1/3)).\ncalculate_partition_parameter(n): t = ceil(log(n)^(1/3)).\ndmy_algorithm_statistics(graph, source): Run + summary metrics.","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Example:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Problem Statement:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Goal: Limit computation to paths within a maximum distance and collect algorithm statistics for analysis/tuning.\nInput: Graph, source vertex, bound max_distance.\nOutput: Bounded distance vector (INF beyond bound) and a statistics dictionary including runtime and parameters.\nRationale: Bounding reduces needless exploration; instrumentation reveals behavior and settings.","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"bounded = dmy_sssp_bounded!(graph, 1, 2.5)           # [0.0, 1.0, 2.0, INF]\nalgo_stats = dmy_algorithm_statistics(graph, 1)\n@show algo_stats[\"runtime_seconds\"], algo_stats[\"pivot_threshold\"]","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Explanation:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"dmy_sssp_bounded!: Sets the bound B = max_distance and ensures relaxations never exceed it; distances beyond the bound remain INF.\nbounded result shows only vertices within 2.5 are assigned finite distances.\ndmy_algorithm_statistics: Validates and runs the algorithm, capturing execution time, graph size, and the theoretical pivot/partition parameters derived from n.","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Note: The internals (BMSSP relaxation, pivot selection, block partitioning) are orchestrated via recursive_layer! under dmy_sssp!; you typically won’t call them directly unless instrumenting the algorithm.","category":"page"},{"location":"cheatsheet/#Preference-and-Connectivity","page":"Cheat Sheet","title":"Preference & Connectivity","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"calculate_distance_ratio(graph, source, target1, target2): Ratio dist(target1)/dist(target2) with robust INF handling.\ncalculate_path_preference(graph, source, preferred, alternative): Inverse ratio (higher → preferred is closer).\nfind_reachable_vertices(graph, source, max_distance=INF): Vertices within threshold.\nanalyze_connectivity(graph, source): Counts + mean/min/max distances.\ncompare_sources(graph, sources, target): Per-source distance map.","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Example:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Problem Statement:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Goal: Quantify preference between two targets, list vertices reachable within a threshold, summarize connectivity, and compare multiple sources to a single target.\nInput: Graph, source(s), target(s), and optional distance threshold.\nOutput: Distance ratio and inverse preference score, reachable vertex list, connectivity metrics, and source→target distance map.\nRationale: Support selection and planning decisions with interpretable metrics based on shortest-path distances.","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"ratio = calculate_distance_ratio(graph, 1, 2, 3)    # 1.0 / 2.0 = 0.5\npref  = calculate_path_preference(graph, 1, 3, 2)   # inverse of ratio = 2.0\nnearby = find_reachable_vertices(graph, 1, 2.0)     # [1, 2, 3]\nmetrics = analyze_connectivity(graph, 1)            # Dict with connectivity stats\nsources = [1, 2]; target = 4\nmap = compare_sources(graph, sources, target)       # Dict(1=>4.0, 2=>3.0)","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Explanation:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"calculate_distance_ratio: Computes a relative reachability metric; handles cases where either target is INF (unreachable) gracefully.\ncalculate_path_preference: Uses inverse ratio so lower distance → higher preference score for the preferred target.\nfind_reachable_vertices: Filters all vertices whose computed distance ≤ max_distance.\nanalyze_connectivity: Produces summary stats: how many reachable, mean distance over reachable, min distance (excluding zero), and max distance.\ncompare_sources: Runs shortest paths from each source and returns a Dict(source => dist_to_target) so you can pick the best source.","category":"page"},{"location":"cheatsheet/#Approach-Selection-Guide","page":"Cheat Sheet","title":"Approach Selection Guide","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Shortest Path (single objective):\nUse dmy_sssp! for large, sparse graphs; validate with compare_with_dijkstra.\nUse dmy_sssp_bounded! when only near-neighborhoods matter to limit work.\nMulti-Objective (trade-offs):\nWeighted Sum (weighted_sum_approach):\nCombine objectives into one cost with weights; fast but may miss non-convex Pareto points.\nRequires all objectives expressed as costs (:min). Transform maximize metrics first.\nEpsilon Constraint (epsilon_constraint_approach):\nOptimize a primary objective with one-sided bounds on others.\nFor two-sided ranges, filter compute_pareto_front by lower/upper bounds, then select by primary objective.\nLexicographic (lexicographic_approach):\nStrict priority ordering (e.g., cost → toxicity → efficacy); keeps edges that preserve optimality at each level.\nRequires cost-type objectives (:min).\nKnee Point (get_knee_point):\nHeuristic to pick the best trade-off after normalizing objectives; good default when no strict preferences.\nDomain Wrappers:\nUse Pharma convenience functions (create_drug_target_network, create_metabolic_pathway, create_treatment_protocol) to build graphs from domain data and then apply generic utilities.","category":"page"},{"location":"cheatsheet/#Multi-Objective-Shortest-Paths-(MOSP)","page":"Cheat Sheet","title":"Multi-Objective Shortest Paths (MOSP)","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Data structures:\nMultiObjectiveGraph, MultiObjectiveEdge, ParetoSolution.\nCore:\ncompute_pareto_front(mog, source, target; max_solutions=100): Enumerates non-dominated path labels.\nScalarization and selection:\nepsilon_constraint_approach(mog, source, target, primary_objective, constraints): Filter by constraints, then choose best on primary objective.\nlexicographic_approach(mog, source, target, priority_order): Optimize objectives in priority order (requires cost-type objectives).\nweighted_sum_approach(mog, source, target, weights): Reduce to single objective (requires all objectives as costs).\nget_knee_point(pareto_front): Heuristic best trade-off.","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Example (build a small multi-objective graph):","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Problem Statement:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Goal: Find Pareto-optimal paths between source and target across three objectives: efficacy (maximize), toxicity (minimize), and cost (minimize).\nInput: MultiObjectiveGraph with edges carrying 3 objective values per edge; in the example, source = 1 and target = 5 for clarity.\nOutput: A Pareto front of non-dominated solutions, a knee-point trade-off solution, and a constrained-best solution with toxicity ≤ 0.25 and cost ≤ 80 optimizing cost.\nAssumptions: Objective senses are [:max, :min, :min]; path objectives are component-wise sums; dominance respects per-objective sense.\nRationale: Label-setting enumerates non-dominated paths; knee-point selects a balanced trade-off; epsilon constraints focus on feasible regions.","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Topology (example graph):","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"flowchart LR\n  1[1] -->|e1| 2[2]\n  1 -->|e2| 3[3]\n  2 -->|e3| 4[4]\n  2 -->|e4| 5[5]\n  3 -->|e5| 4\n  3 -->|e6| 5","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"ASCII fallback (compact):","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"[1]─(e1)→[2]─(e3)→[4]\n │       └(e4)→[5]\n └(e2)→[3]─(e5)→[4]\n         └(e6)→[5]","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Edge legend:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"e1: [0.8, 0.2, 100.0]   (efficacy, toxicity, cost)\ne2: [0.5, 0.1, 200.0]\ne3: [0.9, 0.3, 50.0]\ne4: [0.7, 0.4, 75.0]\ne5: [0.6, 0.1, 80.0]\ne6: [0.8, 0.15, 60.0]","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Adjacency summary:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"adj[1] == [1, 2] (edges 1 and 2 start at 1)\nadj[2] == [3, 4] (edges 3 and 4 start at 2)\nadj[3] == [5, 6] (edges 5 and 6 start at 3)\nadj[4] == [], adj[5] == [] (no outgoing edges)","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"using OptimShortestPaths: MultiObjectiveGraph, MultiObjectiveEdge,               # import MO types\n                          compute_pareto_front, epsilon_constraint_approach, get_knee_point  # import MO algorithms\n\n# Topology: 5 vertices total; source=1 chooses between 2 or 3, then reaches 4 or 5.\n# Objectives per edge: [efficacy (maximize), toxicity (minimize), cost (minimize)].\nedges_mo = [\n    MultiObjectiveEdge(1, 2, [0.8, 0.2, 100.0], 1),  # high efficacy to 2; moderate toxicity; medium cost; id=1\n    MultiObjectiveEdge(1, 3, [0.5, 0.1, 200.0], 2),  # lower efficacy to 3; lower toxicity; higher cost; id=2\n    MultiObjectiveEdge(2, 4, [0.9, 0.3, 50.0], 3),   # strong efficacy via 2->4; higher tox; low cost; id=3\n    MultiObjectiveEdge(2, 5, [0.7, 0.4, 75.0], 4),   # decent efficacy via 2->5; higher tox; medium cost; id=4\n    MultiObjectiveEdge(3, 4, [0.6, 0.1, 80.0], 5),   # moderate efficacy via 3->4; low tox; medium-high cost; id=5\n    MultiObjectiveEdge(3, 5, [0.8, 0.15, 60.0], 6),  # good efficacy via 3->5; low-moderate tox; lower cost; id=6\n]\n\n# Build adjacency lists so each vertex knows its outgoing MO edge indices.\nadj = [Int[] for _ in 1:5]                            # one outgoing list per vertex\nfor (i, e) in enumerate(edges_mo)\n    push!(adj[e.source], i)                           # store the i-th edge index under its source vertex\nend\n\n# Construct the multi-objective graph.\nmog = MultiObjectiveGraph(\n    5,                    # number of vertices\n    edges_mo,             # MO edges with 3 objective values each\n    3,                    # number of objectives (efficacy, toxicity, cost)\n    adj,                  # adjacency of MO edge indices\n    [\"efficacy\", \"toxicity\", \"cost\"],\n    objective_sense=[:max, :min, :min],  # specify which objectives to maximize vs minimize\n)\n\n# Enumerate Pareto-optimal paths from source=1 to target=5.\npareto = compute_pareto_front(mog, 1, 5)              # returns non-dominated solutions with (objectives, path)\n\n# Pick a balanced solution (“knee point”) among the Pareto front.\nknee   = get_knee_point(pareto)                        # heuristic: farthest from utopia-nadir line after normalization\n@show knee.objectives, knee.path                       # inspect the chosen trade-off and its vertex path\n\n# Constrained selection: keep only solutions with toxicity ≤ 0.25 and cost ≤ 80. Primary objective to optimize = cost (index 3).\nbest = epsilon_constraint_approach(mog, 1, 5, 3, [Inf, 0.25, 80.0])\n@show best.objectives, best.path                       # inspect constrained-best by primary objective","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Explanation:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"edges_mo: Each MultiObjectiveEdge carries a 3-vector [efficacy, toxicity, cost]; these are per-edge objective contributions.\nadj: A per-vertex list of outgoing multi-objective edge indices; used for label expansion.\nobjective_sense=[:max, :min, :min]: Efficacy is a maximize objective; toxicity and cost are minimize.\ncompute_pareto_front(mog, 1, 5): Performs label-setting expansion from source 1 to target 5, storing only non-dominated labels (paths) at each vertex.\nget_knee_point(pareto): Normalizes objectives and selects a “knee” solution with a strong trade-off across objectives.\nepsilon_constraint_approach(..., primary_objective=3, constraints=[Inf, 0.25, 80.0]): Filters Pareto solutions to those with toxicity ≤ 0.25 and cost ≤ 80, then picks the best on the primary objective (cost).","category":"page"},{"location":"cheatsheet/#Two-Sided-Constraints-(Objective-Ranges)","page":"Cheat Sheet","title":"Two-Sided Constraints (Objective Ranges)","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Problem Statement:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Goal: Select the best path subject to two-sided bounds per objective (e.g., toxicity within [0.2, 0.35] and cost ≤ 80) while optimizing a primary objective.\nInput: lower_bounds and upper_bounds arrays of length mog.n_objectives. Use -Inf/Inf to leave sides unbounded.\nOutput: The best ParetoSolution that satisfies all ranges, chosen by the primary objective’s sense.\nRationale: The built-in epsilon_constraint_approach applies one-sided constraints; for two-sided bounds, filter the Pareto front and then select by the primary objective.","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Example:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"# Define two-sided bounds per objective:\n# [efficacy, toxicity, cost]\nlower_bounds = [-Inf, 0.20, -Inf]   # toxicity must be ≥ 0.20 (example); others unbounded below\nupper_bounds = [ Inf, 0.35, 80.0]   # toxicity ≤ 0.35; cost ≤ 80.0; efficacy unbounded above\n\ntol = 1e-10  # numerical tolerance for comparisons\n\n# Compute Pareto front from source=1 to target=5\npareto = compute_pareto_front(mog, 1, 5)\n\n# Helper to check range with tolerance\nin_range(val, lb, ub, tol) = (val >= lb - tol) && (val <= ub + tol)\n\n# Filter solutions that satisfy all two-sided bounds\nvalid = [\n    sol for sol in pareto\n    if all(in_range(sol.objectives[i], lower_bounds[i], upper_bounds[i], tol)\n            for i in 1:mog.n_objectives)\n]\n\nif isempty(valid)\n    # No solution meets constraints; handle as needed\n    best_range_sol = ParetoSolution(fill(Inf, mog.n_objectives), Int[], zeros(Int, mog.n_vertices))\nelse\n    primary = 3  # optimize cost (index 3); change as needed\n    scores = [sol.objectives[primary] for sol in valid]\n    best_idx = mog.objective_sense[primary] === :min ? argmin(scores) : argmax(scores)\n    best_range_sol = valid[best_idx]\nend\n\n@show best_range_sol.objectives, best_range_sol.path","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Notes:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Two-sided bounds apply to the achieved objective values directly, irrespective of :min/:max. The sense only affects how you select the “best” among feasible solutions (minimize or maximize the primary objective).\nYou can mix ranges across objectives (e.g., efficacy ∈ [0.6, 0.9], toxicity ≤ 0.3, cost ∈ [20, 70]).\nIf you routinely need two-sided bounds, consider wrapping this pattern in a helper function.","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Notes:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"For weighted_sum_approach or lexicographic_approach, all objectives must be expressed as costs (:min). Transform maximize objectives appropriately (e.g., cost = 1.0 - efficacy or a normalized negative) before calling.","category":"page"},{"location":"cheatsheet/#Pharma-Conveniences-(Domain-Wrappers)","page":"Cheat Sheet","title":"Pharma Conveniences (Domain Wrappers)","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"create_drug_target_network(drugs, targets, interactions): Builds a bidirectional graph with normalized distances from binding affinities (safe for values > 1.0).\nfind_drug_target_paths(network, drug, target): Returns (distance, names_path).\nanalyze_drug_connectivity(network, drug): Reachability and distance stats across targets.\ncreate_metabolic_pathway(metabolites, reactions, costs, reaction_network): Directed reaction edges with costs.\nfind_metabolic_pathway(pathway, start, end): Returns (total_cost, names_path).\ncreate_treatment_protocol(treatments, costs, efficacy_weights, transitions): Combined cost = transition_cost + costs[to] / max(efficacy[to], 1e-6).\noptimize_treatment_sequence(protocol, start, end): Returns (total_cost, treatment_sequence).","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Example (drug-target):","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Problem Statement:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Goal: Build a drug-target interaction network from an affinity matrix, find the shortest path from a named drug to a named target, and analyze connectivity for that drug.\nInput: Drug names, target names, and a non-negative affinity matrix (drug × target).\nOutput: Shortest-path distance and sequence of names from the drug to the target; connectivity statistics for the drug.\nAssumptions: Affinities ≥ 0; converted to distances via -log(a/(1+a)) to ensure non-negative weights while preserving ordering.\nRationale: Transform pharmacological binding strengths into metric costs suitable for shortest-path algorithms.","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"drugs    = [\"Aspirin\", \"Ibuprofen\"]             # drug names -> vertices 1..length(drugs)\ntargets  = [\"COX1\", \"COX2\"]                     # target names -> vertices after drug block\ninteract = [1.0 0.2; 0.5 0.8]                     # affinity matrix (drug × target); non-zero creates edges\nnetwork  = create_drug_target_network(drugs, targets, interact)  # converts affinity to distance via -log(a/(1+a))\n\n(distance, path_names) = find_drug_target_paths(network, \"Aspirin\", \"COX2\")  # shortest path from drug to target\nanalysis = analyze_drug_connectivity(network, \"Aspirin\")                       # reachability/summary from this drug\n@show distance, path_names, analysis[\"reachable_targets\"], analysis[\"avg_target_distance\"]","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Explanation:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"drugs, targets: Names mapped to vertex IDs; drugs first, then targets, to form a single graph.\ninteract: A length(drugs) × length(targets) matrix of affinities; non-zero values create edges both ways (drug→target and target→drug).\ncreate_drug_target_network: Normalizes affinity to distance via -log(affinity/(1+affinity)) to guarantee non-negative weights while preserving ordering.\nfind_drug_target_paths: Solves for shortest path from a named drug to a named target; returns numeric distance and a names sequence.\nanalyze_drug_connectivity: Runs SSSP from a drug vertex and summarizes how many targets are reachable and the distribution of target distances.","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Example (metabolic + treatment):","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Problem Statement:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Metabolic Pathway:\nGoal: Find a minimum-cost sequence of metabolites from a start to an end metabolite.\nInput: Metabolite names, reaction names and costs, and a directed substrate→product reaction network.\nOutput: Total pathway cost and ordered metabolite sequence.\nRationale: Model biochemical pathways as directed edges with costs and solve via SSSP.\nTreatment Protocol:\nGoal: Find an optimal treatment sequence minimizing combined transition and treatment costs (penalized by low efficacy).\nInput: Treatment steps, per-step costs, efficacy weights, and allowed transitions with costs.\nOutput: Total plan cost and ordered treatment sequence.\nAssumptions: Combined edge cost = transition_cost + costs[to]/max(efficacy[to], 1e-6).\nRationale: Encode clinical trade-offs as edge costs and use SSSP to plan.","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"# Metabolic pathway\nmetabolites = [\"A\", \"B\", \"C\"]                   # names mapped to vertices\nreactions   = [\"r1\", \"r2\"]                      # reaction identifiers (metadata)\ncosts       = [1.0, 2.0]                          # per-reaction cost (non-negative)\nrxn_net     = [(\"A\", \"r1\", \"B\"), (\"B\", \"r2\", \"C\")]  # directed substrate→product steps\npathway     = create_metabolic_pathway(metabolites, reactions, costs, rxn_net)  # build graph from reactions\n(pcost, mpath) = find_metabolic_pathway(pathway, \"A\", \"C\")                    # shortest cost sequence of metabolites\n\n# Treatment protocol\ntreatments = [\"Diagnosis\", \"Chemo\", \"Recovery\"]        # clinical steps → vertices\ntcosts     = [1.0, 5.0, 2.0]                            # intrinsic per-step costs\neff        = [1.0, 0.6, 0.9]                            # efficacy weights per step\ntrans      = [(\"Diagnosis\", \"Chemo\", 0.5), (\"Chemo\", \"Recovery\", 1.0)]  # allowed transitions + transition costs\nprotocol   = create_treatment_protocol(treatments, tcosts, eff, trans)     # combined cost: transition + cost/efficacy\n(total_cost, seq) = optimize_treatment_sequence(protocol, \"Diagnosis\", \"Recovery\")  # minimal plan and sequence","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Explanation:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Metabolic: metabolites map to vertices; reactions name edges; costs are per-reaction edge weights; rxn_net defines directed substrate→product links. We construct a graph so shortest paths represent minimal total reaction cost.\nTreatment: treatments map to vertices; tcosts are per-treatment intrinsic costs; eff are efficacy weights; trans defines allowable transitions and their costs. The combined edge cost penalizes lower efficacy via costs[to] / max(efficacy[to], 1e-6) plus the transition cost.\noptimize_treatment_sequence returns the total plan cost and the ordered treatment steps.","category":"page"},{"location":"cheatsheet/#End-to-End-Example:-Generic-Graph-Walkthrough","page":"Cheat Sheet","title":"End-to-End Example: Generic Graph Walkthrough","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Goal: Build a graph, solve shortest paths, verify, and analyze.","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Problem Statement:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Goal: End-to-end shortest-path workflow from graph construction to validation and analysis.\nInput: A small directed graph with non-negative weights; source vertex 1.\nOutput: Distances, reconstructed path, formatted report, correctness comparison, connectivity metrics, and bounded distances.\nRationale: Demonstrate the full pipeline in a minimal example.","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"include(\"src/OptimShortestPaths.jl\"); using .OptimShortestPaths\n\n# Step 1 — Build and validate\naedges   = [\n    Edge(1,2,1),  # edge 1: 1->2; index=1 must equal position 1 so weights[1] maps here\n    Edge(2,3,2),  # edge 2: 2->3; index=2 aligns with position 2 and weights[2]\n    Edge(1,3,3),  # edge 3: 1->3; index=3 aligns with position 3 and weights[3]\n    Edge(3,4,4),  # edge 4: 3->4; index=4 aligns with position 4 and weights[4]\n]\naweights = [\n    1.0,  # cost of edge[1] (1->2); non-negative to satisfy DMY requirements\n    1.0,  # cost of edge[2] (2->3)\n    3.0,  # cost of edge[3] (1->3)\n    2.0,  # cost of edge[4] (3->4)\n]\naGraph   = DMYGraph(4, aedges, aweights)  # build adjacency lists; validate index/weight alignment and vertex bounds\nvalidate_graph(aGraph)                    # extra safety: throw if structure is inconsistent\n\n# Step 2 — Solve and inspect\n(dist, parent) = dmy_sssp_with_parents!(aGraph, 1)   # run DMY from source=1; also return parent pointers for path reconstruction\n@show dist                                           # show all computed distances (INF for unreachable)\n@show reconstruct_path(parent, 1, 4)                 # rebuild path 1->4 using parent[] (should be [1,2,3,4])\nprintln(format_distance_results(dist, 1))            # human-readable summary with reachability totals\n\n# Step 3 — Compare and analyze\ncmp = compare_with_dijkstra(aGraph, 1)               # cross-check DMY vs simple Dijkstra baseline\n@assert cmp[\"results_match\"]                         # ensure distances match within tolerance\nmetrics = analyze_connectivity(aGraph, 1)            # compute reachable counts and average/min/max distances\n@show metrics[\"reachable_count\"], metrics[\"avg_distance\"]\n\n# Quick preferences and sources\n@show calculate_distance_ratio(aGraph, 1, 2, 3)      # ratio dist(1->2)/dist(1->3) = 0.5\n@show calculate_path_preference(aGraph, 1, 3, 2)     # inverse ratio preference; higher means preferred is closer\nsources = [1, 2]; target = 4                         # compare multiple sources to a single target\n@show compare_sources(aGraph, sources, target)       # map of source->distance (e.g., Dict(1=>4.0, 2=>3.0))\n\n# Step 4 — Bounded search\nbounded = dmy_sssp_bounded!(aGraph, 1, 2.5)          # compute only within distance ≤ 2.5 (others INF)","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Explanation:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Step 1: Construct Edge and weights vectors and create DMYGraph. validate_graph guards against structural errors.\nStep 2: Compute distances with parents, reconstruct a sample path, and print a readable summary.\nStep 3: Compare results to a reference Dijkstra solver for correctness and get connectivity stats from source.\nPreferences and sources: Demonstrate preference scoring and selecting the best source for a target.\nStep 4: Show how bounding limits exploration to near neighbors.","category":"page"},{"location":"cheatsheet/#End-to-End-Example:-Multi-Objective-Walkthrough","page":"Cheat Sheet","title":"End-to-End Example: Multi-Objective Walkthrough","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Goal: Explore Pareto solutions and pick a knee-point or constrained best.","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"This walkthrough is detailed above in the \"Multi-Objective Shortest Paths (MOSP)\" section with a topology diagram and fully commented code. Refer there to avoid duplication.","category":"page"},{"location":"cheatsheet/#Troubleshooting-and-Tips","page":"Cheat Sheet","title":"Troubleshooting & Tips","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Negative weights: Not supported; ensure weights ≥ 0.\nUnreachable vertices: Distances return INF; path reconstruction yields Int[].\nIndexing: Vertices are 1-based; validate with validate_vertex if unsure.\nMixed objective senses: Prefer compute_pareto_front or epsilon_constraint_approach. For weighted_sum_approach or lexicographic_approach, convert all objectives to cost-type first.\nTiming: Extremely fast runs can skew speedup; rely on correctness checks (results_match, max_difference).","category":"page"},{"location":"cheatsheet/#Performance-Notes","page":"Cheat Sheet","title":"Performance Notes","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Use dmy_sssp_bounded! when only near neighborhoods matter.\nFor large, sparse graphs, DMY scales better than naive Dijkstra; validate with compare_with_dijkstra.\nInstrument with dmy_algorithm_statistics (and pivot stats if needed) to understand frontier behavior.","category":"page"},{"location":"cheatsheet/#Test-and-Validation","page":"Cheat Sheet","title":"Test & Validation","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Run all tests:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"julia --project=. test/runtests.jl","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Run a specific suite:","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"julia --project=. test/test_dmy_algorithm.jl\njulia --project=. test/test_pharma_networks.jl\njulia --project=. test/test_multi_objective.jl","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"This cheat sheet mirrors the public API in src/OptimShortestPaths.jl and demonstrates practical usage across generic and domain-specific workflows, with detailed explanations alongside each example.","category":"page"},{"location":"cheatsheet/#Comprehensive-Function-Reference-(Cheat-Sheet-Tables)","page":"Cheat Sheet","title":"Comprehensive Function Reference (Cheat Sheet Tables)","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Below is a category-based summary of essential types and functions, including purpose, inputs/outputs, constraints, and quick examples.","category":"page"},{"location":"cheatsheet/#Core-Types-and-Problem-Casting","page":"Cheat Sheet","title":"Core Types & Problem Casting","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Name Purpose Inputs Outputs Notes Example\nEdge Directed edge, aligns with weight index source::Int, target::Int, index::Int Edge index == position in edges; vertices 1..n Edge(1,2,1)\nDMYGraph Adjacency-list graph for DMY n_vertices::Int, edges::Vector{Edge}, weights::Vector{Float64} DMYGraph All weights ≥ 0; length(weights)==length(edges) DMYGraph(4, edges, weights)\nBlock Partition unit for recursion vertices::Vector{Int}, frontier::OrderedSet, upper_bound::Float64 Block Used internally by recursion —\nOptimizationProblem Container for problem casting type::Symbol, data, source::Int OptimizationProblem Source > 0 OptimizationProblem(:drug_discovery, (drugs,targets,mat), 1)\ncast_problem Build graph from problem type problem_type::Symbol, data DMYGraph Types: :drug_discovery, :metabolic, :treatment cast_problem(:metabolic, args)\noptimize_to_graph Cast then solve with solver problem, solver=:dmy Vector{Float64} Requires non-negative weights optimize_to_graph(prob)\nobjectives_to_weights Map objective functions → weights objectives::Vector{Function}, edge_data::Any Vector{Float64} For custom scalarization objectives_to_weights(fns, edge)","category":"page"},{"location":"cheatsheet/#DMY-Algorithm-and-Variants","page":"Cheat Sheet","title":"DMY Algorithm & Variants","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Name Purpose Inputs Outputs Notes Example\ndmy_sssp! Single-source shortest paths graph::DMYGraph, source::Int Vector{Float64} Validates graph; weights ≥ 0 dmy_sssp!(graph, 1)\ndmy_sssp_with_parents! Distances + parent pointers graph, source (dist::Vector{Float64}, parent::Vector{Int}) Path reconstruction via parent dmy_sssp_with_parents!(graph, 1)\ndmy_sssp_bounded! SSSP with max distance bound graph, source, max_distance Vector{Float64} Ignores paths > bound dmy_sssp_bounded!(graph, 1, 2.5)\nvalidate_dmy_input Input validation graph, source Bool Throws on invalid validate_dmy_input(graph, 1)\ndmy_algorithm_statistics Run + report stats graph, source Dict{String,Any} Runtime, counts, averages dmy_algorithm_statistics(graph, 1)\nrecursive_layer! Core recursion (internal) graph, dist, parent, U, S, B Nothing Uses BMSSP, pivots, blocks —\ncalculate_pivot_threshold k = `ceil( U ^(1/3))` U_size::Int Int\ncalculate_partition_parameter t = ceil(log(n)^(1/3)) n::Int Int Depth control calculate_partition_parameter(1000)","category":"page"},{"location":"cheatsheet/#BMSSP-(Bounded-Multi-Source-Shortest-Path)","page":"Cheat Sheet","title":"BMSSP (Bounded Multi-Source Shortest Path)","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Name Purpose Inputs Outputs Notes Example\nbmssp! k rounds of bounded relaxations graph, dist, parent, frontier, bound, k OrderedSet{Int} Updates dist/parent in-place bmssp!(graph, dist, parent, S, B, k)\nbmssp_single_round! One relaxation round graph, dist, parent, frontier, bound (next_frontier, updated_any) Fine-grained step bmssp_single_round!(...)\nbmssp_with_statistics! BMSSP + stats same as bmssp! Dict{String,Any} Rounds, updates, relaxations bmssp_with_statistics!(...)\ncount_relaxations Count candidate relaxations graph, frontier, bound, dist Int Diagnostics count_relaxations(...)\nvalidate_bmssp_input Validate BMSSP inputs graph, dist, parent, frontier, bound, k Bool Throws on invalid validate_bmssp_input(...)","category":"page"},{"location":"cheatsheet/#Pivot-Selection-and-Partitioning","page":"Cheat Sheet","title":"Pivot Selection & Partitioning","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Name Purpose Inputs Outputs Notes Example\nselect_pivots Distance-based pivot sampling U_tilde, S, k, dist Vector{Int} ≤ ` U_tilde\nselect_pivots_advanced Distance + degree scoring U_tilde, S, k, dist, graph Vector{Int} Prefers low dist + high degree select_pivots_advanced(...)\nvalidate_pivot_selection Check pivot constraints pivots, U_tilde, k Bool No duplicates; subset of U_tilde validate_pivot_selection(...)\npivot_selection_statistics Summarize pivots U_tilde, S, k, pivots, dist Dict{String,Any} Dist ranges, reduction pivot_selection_statistics(...)\npartition_blocks Distance-sorted blocks U, dist, t, B=INF Vector{Block} Seeds frontier, upper bound partition_blocks(U,dist,t,B)\npartition_blocks_adaptive Balanced blocks U, dist, t, graph, B=INF Vector{Block} Size-balanced partitions partition_blocks_adaptive(...)","category":"page"},{"location":"cheatsheet/#Graph-Utilities-2","page":"Cheat Sheet","title":"Graph Utilities","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Name Purpose Inputs Outputs Notes Example\nvalidate_graph Structural validation graph Bool Weights finite/≥0; indices valid validate_graph(graph)\ncreate_simple_graph Build from tuples n_vertices, edge_list[(u,v,w)] DMYGraph Non-negative weights create_simple_graph(3, [(1,2,0.5),(2,3,1.0)])\nvertex_count / edge_count Basic counts graph Int — vertex_count(graph)\nout_degree / outgoing_edges Degree/edges per vertex graph, vertex Int / Vector{Int} Bounds checked out_degree(graph, 1)\niterate_edges (edge, weight) pairs graph, vertex Vector{Tuple} From adjacency list iterate_edges(graph, 1)\nfind_edge Find edge id from u→v graph, source, target Union{Int,Nothing} First match find_edge(graph, 1, 3)\nget_edge_weight / get_edge Access by id graph, edge_index Float64 / Edge Bounds checked get_edge_weight(graph, 2)\nget_edge_weight_between Weight from u→v graph, u, v Union{Float64,Nothing} First match get_edge_weight_between(graph,1,3)\nis_connected Has direct u→v? graph, u, v Bool Edge existence only is_connected(graph,1,3)\ngraph_density Edge density graph Float64 Directed: m/(n(n-1)) graph_density(graph)\nhas_self_loops Self-loop presence graph Bool — has_self_loops(graph)\nget_vertices_by_out_degree Sorted (v,deg) graph Vector{Tuple} Descending get_vertices_by_out_degree(graph)\nvalidate_vertex Bounds check graph, vertex Bool 1..n validate_vertex(graph, 3)\nget_all_targets Immediate neighbors graph, source Vector{Int} Targets only get_all_targets(graph, 1)\ngraph_statistics Structure summary graph Dict{String,Any} Degrees, weights graph_statistics(graph)","category":"page"},{"location":"cheatsheet/#Path-and-Analysis-Utilities","page":"Cheat Sheet","title":"Path & Analysis Utilities","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Name Purpose Inputs Outputs Notes Example\nreconstruct_path Build path via parents parent, source, target Vector{Int} Empty if invalid reconstruct_path(parent,1,4)\nshortest_path_tree Map vertex→path parent, source Dict{Int,Vector{Int}} Reachable only shortest_path_tree(parent,1)\npath_length Sum weights along path path, graph Float64 INF if hop missing path_length([1,2,3,4],graph)\nverify_shortest_path Triangle check graph, dist, source, target Bool Tolerance allowed verify_shortest_path(graph,dist,1,4)\nformat_distance_results Pretty summary dist, source String Reachability included println(format_distance_results(dist,1))\ncompare_with_dijkstra Baseline comparison graph, source Dict{String,Any} Times, diffs, match flag compare_with_dijkstra(graph,1)\ncalculate_distance_ratio dist1/dist2 graph, source, t1, t2 Float64 Robust to INF calculate_distance_ratio(graph,1,2,3)\ncalculate_path_preference Inverse ratio graph, source, preferred, alternative Float64 Higher→preferred closer calculate_path_preference(graph,1,3,2)\nfind_reachable_vertices ≤ threshold graph, source, max_distance=INF Vector{Int} Bound aware find_reachable_vertices(graph,1,2.5)\nanalyze_connectivity Reachability stats graph, source Dict{String,Any} Counts + mean/min/max analyze_connectivity(graph,1)\ncompare_sources Source→target map graph, sources, target Dict{Int,Float64} Simple selector compare_sources(graph,[1,2],4)\nfind_shortest_path (distance, path) graph, source, target (Float64, Vector{Int}) Uses parents find_shortest_path(graph,1,4)\ngraph_reachability BFS set graph, source Set{Int} Unweighted reachability graph_reachability(graph,1)","category":"page"},{"location":"cheatsheet/#Multi-Objective","page":"Cheat Sheet","title":"Multi-Objective","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Name Purpose Inputs Outputs Notes Example\nMultiObjectiveEdge Edge with objective vector source, target, weights::Vector, edge_id MultiObjectiveEdge Length(weights)==n_objectives MultiObjectiveEdge(1,2,[0.8,0.2,100.0],1)\nMultiObjectiveGraph Graph with n objectives n_vertices, edges, n_objectives, adjacency, names, objective_sense MultiObjectiveGraph Sense ∈ (:min,:max) MultiObjectiveGraph(5,edges,3,adj,names;objective_sense=[:max,:min,:min])\nParetoSolution Non-dominated solution objectives, path, parent ParetoSolution Returned by algorithms —\ncompute_pareto_front Enumerate Pareto paths mog, source, target, max_solutions=100 Vector{ParetoSolution} Label-setting; dominance compute_pareto_front(mog,1,5)\nweighted_sum_approach Scalarization (cost-only) mog, source, target, weights ParetoSolution All senses must be :min weighted_sum_approach(mog,1,5,[0.3,0.2,0.5])\nepsilon_constraint_approach One-sided constraints mog, source, target, primary_objective, constraints ParetoSolution Filters then optimize primary epsilon_constraint_approach(mog,1,5,3,[Inf,0.25,80.0])\nlexicographic_approach Priority ordering (cost-only) mog, source, target, priority_order ParetoSolution All senses must be :min lexicographic_approach(mog,1,5,[3,2,1])\nget_knee_point Knee-point selection pareto_front Union{ParetoSolution,Nothing} Heuristic trade-off get_knee_point(pareto)\ncompute_path_objectives Sum objectives along path mog, parent, source, target, edge_indices? Vector{Float64} Supports edge mapping compute_path_objectives(mog,parent,1,5)","category":"page"},{"location":"cheatsheet/#Pharma-Conveniences","page":"Cheat Sheet","title":"Pharma Conveniences","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Name Purpose Inputs Outputs Notes Example\nPharmaNetwork Abstract base type — — Domain wrapper —\nDrugTargetNetwork Drug-target domain drugs, targets, interactions DrugTargetNetwork Affinities ≥ 0 create_drug_target_network(drugs,targets,mat)\nMetabolicPathway Metabolic domain metabolites, reactions, costs, reaction_network MetabolicPathway Costs ≥ 0 create_metabolic_pathway(metabs,rxns,costs,net)\nTreatmentProtocol Treatment domain treatments, costs, efficacy, transitions TreatmentProtocol Costs/eff ≥ 0 create_treatment_protocol(treats,costs,eff,trans)\ncreate_drug_target_network Build graph from affinity drugs, targets, interactions DrugTargetNetwork Distance = -log(a/(1+a)) create_drug_target_network(...)\nfind_drug_target_paths Path from drug→target network, drug_name, target_name (Float64, Vector{String}) Uses DMY parents find_drug_target_paths(net,\"Aspirin\",\"COX2\")\nanalyze_drug_connectivity Target reachability stats network, drug_name Dict{String,Any} Counts + averages analyze_drug_connectivity(net,\"Aspirin\")\ncreate_metabolic_pathway Build reaction graph metabolites, reactions, costs, reaction_network MetabolicPathway Directed edges by reactions create_metabolic_pathway(...)\nfind_metabolic_pathway Path cost + names pathway, start, end (Float64, Vector{String}) DMY + reconstruct find_metabolic_pathway(pathway,\"A\",\"C\")\ncreate_treatment_protocol Build treatment graph treatments, costs, efficacy, transitions TreatmentProtocol Combined edge cost create_treatment_protocol(...)\noptimize_treatment_sequence Minimal plan sequence protocol, start, end (Float64, Vector{String}) DMY + reconstruct optimize_treatment_sequence(protocol,\"Diag\",\"Recov\")","category":"page"},{"location":"cheatsheet/#Detailed-Output-Keys-(Analysis-Functions)","page":"Cheat Sheet","title":"Detailed Output Keys (Analysis Functions)","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"These analysis functions are already listed in the Comprehensive Function Reference above. This section enumerates their returned keys and links them to the relevant category, with function names highlighted for quick cross-reference.","category":"page"},{"location":"cheatsheet/#dmy_algorithm_statistics(graph,-source)-—-DMY-Algorithm-and-Variants","page":"Cheat Sheet","title":"dmy_algorithm_statistics(graph, source) — DMY Algorithm & Variants","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Inputs: graph::DMYGraph, source::Int Returns: Dict{String,Any}","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Output Key Meaning\ngraph_vertices Number of vertices in the graph\ngraph_edges Number of edges in the graph\nsource_vertex Source vertex used for SSSP\npivot_threshold k parameter (ceil(n^(1/3))) used in sparsification\npartition_parameter t parameter (ceil(log(n)^(1/3))) used in partitioning\nruntime_seconds Total runtime to compute distances\ndistances_computed Count of vertices with finite distance\nunreachable_vertices Count of vertices with INF distance\nmax_distance Maximum finite distance\navg_distance Average of finite distances","category":"page"},{"location":"cheatsheet/#bmssp_with_statistics!(graph,-dist,-parent,-frontier,-bound,-k)-—-BMSSP","page":"Cheat Sheet","title":"bmssp_with_statistics!(graph, dist, parent, frontier, bound, k) — BMSSP","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Inputs: graph::DMYGraph, dist::Vector{Float64}, parent::Vector{Int}, frontier::AbstractSet{Int}, bound::Float64, k::Int Returns: Dict{String,Any}","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Output Key Meaning\ninitial_frontier_size Size of frontier at start\nrounds_performed Number of BMSSP rounds executed\ntotal_relaxations Total edge relaxations attempted\nvertices_updated Count of vertices updated across rounds\nearly_termination True if algorithm stopped early (no updates)\nfinal_frontier_size Size of frontier at end","category":"page"},{"location":"cheatsheet/#pivot_selection_statistics(U_tilde,-S,-k,-pivots,-dist)-—-Pivot-Selection-and-Partitioning","page":"Cheat Sheet","title":"pivot_selection_statistics(U_tilde, S, k, pivots, dist) — Pivot Selection & Partitioning","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Inputs: U_tilde::Vector{Int}, S::AbstractSet{Int}, k::Int, pivots::Vector{Int}, dist::Vector{Float64} Returns: Dict{String,Any}","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Output Key Meaning\nU_tilde_size Size of filtered vertex set considered\nfrontier_size Size of current frontier set\npivot_threshold k threshold used in selection\npivots_selected Number of pivots selected\nreduction_ratio pivots_selected / U_tilde_size\nmin_pivot_distance Minimum pivot distance\nmax_pivot_distance Maximum pivot distance\navg_pivot_distance Average pivot distance\nmin_U_tilde_distance Minimum U_tilde distance\nmax_U_tilde_distance Maximum U_tilde distance\navg_U_tilde_distance Average U_tilde distance","category":"page"},{"location":"cheatsheet/#graph_statistics(graph)-—-Graph-Utilities","page":"Cheat Sheet","title":"graph_statistics(graph) — Graph Utilities","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Inputs: graph::DMYGraph Returns: Dict{String,Any}","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Output Key Meaning\nvertices Graph vertex count\nedges Graph edge count\ndensity Edge density (directed)\nhas_self_loops Whether any self-loops exist\nmax_out_degree Maximum out-degree\nmin_out_degree Minimum out-degree\navg_out_degree Average out-degree\nmax_weight Maximum edge weight\nmin_weight Minimum edge weight\navg_weight Average edge weight","category":"page"},{"location":"cheatsheet/#compare_with_dijkstra(graph,-source)-—-Path-and-Analysis-Utilities","page":"Cheat Sheet","title":"compare_with_dijkstra(graph, source) — Path & Analysis Utilities","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Inputs: graph::DMYGraph, source::Int Returns: Dict{String,Any}","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Output Key Meaning\ndmy_time Runtime of DMY (seconds)\ndijkstra_time Runtime of simple Dijkstra (seconds)\nspeedup Ratio dijkstra_time / dmy_time\ndiscrepancies Vertex ids with mismatched distances\nmax_difference Largest absolute distance difference\nresults_match True if all distances match within tolerance","category":"page"},{"location":"cheatsheet/#analyze_connectivity(graph,-source)-—-Path-and-Analysis-Utilities","page":"Cheat Sheet","title":"analyze_connectivity(graph, source) — Path & Analysis Utilities","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Inputs: graph::DMYGraph, source::Int Returns: Dict{String,Any}","category":"page"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Output Key Meaning\nreachable_count Count of vertices with finite distances\nunreachable_count Count of vertices with INF distances\nconnectivity_ratio Fraction reachable\navg_distance Average of finite distances\nmax_distance Maximum finite distance\nmin_distance Minimum finite distance (excluding zero when applicable)","category":"page"},{"location":"cheatsheet/#Constraints-and-Assumptions-Cheatsheet","page":"Cheat Sheet","title":"Constraints & Assumptions Cheatsheet","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Graph weights are non-negative and finite; negative edges are not supported.\nVertices are 1-based indices; always validate with validate_vertex(graph, v) if unsure.\nEdge indices must align: edges[i].index == i and adjacency lists store these indices.\nINF denotes unreachable vertices or distances beyond a bound.\nMulti-objective senses must be declared: objective_sense entries ∈ (:min, :max).\nweighted_sum_approach and lexicographic_approach require all objectives as costs (:min). Transform maximize metrics before calling.\nTwo-sided constraints: filter the Pareto front by ranges (lower/upper bounds), then select by primary objective sense.","category":"page"},{"location":"cheatsheet/#Typical-Pitfalls-and-Remedies","page":"Cheat Sheet","title":"Typical Pitfalls & Remedies","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Pitfall: Mismatched edge indices and weights\nRemedy: Ensure edges[i].index == i; use validate_graph(graph) before running algorithms.\nPitfall: Unreachable paths unexpectedly reported as INF\nRemedy: Check graph connectivity; use graph_reachability(graph, source) and inspect adjacency lists.\nPitfall: Mixed min/max objectives cause incorrect scalarization\nRemedy: Convert maximize objectives to cost equivalents before weighted_sum_approach or lexicographic_approach.\nPitfall: Tight bounds filter out all Pareto solutions\nRemedy: Loosen ranges or consider knee-point selection without constraints.","category":"page"},{"location":"cheatsheet/#Complexity-Snapshot","page":"Cheat Sheet","title":"Complexity Snapshot","text":"","category":"section"},{"location":"cheatsheet/","page":"Cheat Sheet","title":"Cheat Sheet","text":"DMY single-source shortest paths (sparse graphs): approximately O(m · log^(2/3) n); space O(n) for dist/parent.\nBounded SSSP: similar structure; relaxations skip updates beyond bound.\nReference Dijkstra in utilities (simple implementation): not optimized; used for correctness comparison, not performance.","category":"page"},{"location":"examples/#Examples","page":"Overview","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"Complete working examples demonstrating OptimShortestPaths capabilities.","category":"page"},{"location":"examples/#Running-Examples","page":"Overview","title":"Running Examples","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"All examples are located in the examples/ directory. Each has its own Project.toml for isolated dependencies.","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"To run an example:","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"cd examples/drug_target_network\njulia --project=. -e \"using Pkg; Pkg.develop(path=\\\"../..\\\"); Pkg.instantiate()\"\njulia --project=. drug_target_network.jl","category":"page"},{"location":"examples/#Available-Examples","page":"Overview","title":"Available Examples","text":"","category":"section"},{"location":"examples/#1.-Comprehensive-Demo","page":"Overview","title":"1. Comprehensive Demo","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"Location: examples/comprehensive_demo/","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"Complete framework demonstration including:","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"Problem transformation philosophy\nAll three MCDA methods (weighted sum, ε-constraint, lexicographic)\nSupply chain optimization\nPerformance benchmarking\nAlgorithm capabilities showcase","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"Generates: 7 publication-quality figures","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"Run:","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"cd examples/comprehensive_demo\njulia --project=. comprehensive_demo.jl\njulia --project=. generate_figures.jl  # Generate visualizations","category":"page"},{"location":"examples/#2.-Drug-Target-Network","page":"Overview","title":"2. Drug-Target Network","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"Location: examples/drug_target_network/","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"Analyzes drug-target binding affinities and selectivity:","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"COX1/COX2 selectivity analysis\nMulti-objective cost-affinity-specificity optimization\nDrug connectivity metrics\nBinding affinity heatmaps","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"Key insights: Demonstrates how thermodynamic binding affinities map to graph distances.","category":"page"},{"location":"examples/#3.-Metabolic-Pathway","page":"Overview","title":"3. Metabolic Pathway","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"Location: examples/metabolic_pathway/","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"Glycolysis pathway optimization (Embden-Meyerhof-Parnas):","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"ATP yield calculations\nByproduct analysis\nMulti-objective pathway comparison\nPareto front visualization","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"Key insights: Shows bipartite metabolite-reaction network transformation.","category":"page"},{"location":"examples/#4.-Treatment-Protocol","page":"Overview","title":"4. Treatment Protocol","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"Location: examples/treatment_protocol/","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"Cancer treatment pathway optimization:","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"Multi-objective cost-time-quality-success trade-offs\nPatient-specific protocol recommendations\nClinical decision tree analysis\nTreatment sequence optimization","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"Key insights: Handles complex multi-criteria clinical decisions.","category":"page"},{"location":"examples/#5.-Supply-Chain","page":"Overview","title":"5. Supply Chain","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"Location: examples/supply_chain/","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"Multi-echelon logistics network:","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"3 factories → 4 warehouses → 5 distribution centers → 2 customer regions\n22-node network optimization\nFlow analysis and cost minimization\nNetwork topology visualization","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"Key insights: Large-scale real-world graph optimization.","category":"page"},{"location":"examples/#6.-Generic-Utilities-Demo","page":"Overview","title":"6. Generic Utilities Demo","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"Location: examples/generic_utilities_demo.jl","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"Demonstrates domain-agnostic utility functions:","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"find_shortest_path\ncalculate_distance_ratio\nanalyze_connectivity\nfind_reachable_vertices","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"Key insights: Shows how generic functions work on any graph.","category":"page"},{"location":"examples/#Code-Examples","page":"Overview","title":"Code Examples","text":"","category":"section"},{"location":"examples/#Basic-Shortest-Path","page":"Overview","title":"Basic Shortest Path","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"using OptimShortestPaths\n\n# Create graph\nedges = [Edge(1, 2, 1), Edge(2, 3, 2), Edge(1, 3, 3)]\nweights = [1.0, 2.0, 4.0]\ngraph = DMYGraph(3, edges, weights)\n\n# Find shortest path\ndistance, path = find_shortest_path(graph, 1, 3)\n# distance = 3.0, path = [1, 2, 3]","category":"page"},{"location":"examples/#Multi-Objective-Example","page":"Overview","title":"Multi-Objective Example","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"using OptimShortestPaths\nusing OptimShortestPaths.MultiObjective\n\n# Create multi-objective graph\nedges = [\n    MultiObjectiveEdge(1, 2, [1.0, 10.0], 1),  # Cheap but slow\n    MultiObjectiveEdge(2, 3, [2.0, 5.0], 2),   # Moderate\n    MultiObjectiveEdge(1, 3, [5.0, 3.0], 3)    # Expensive but fast\n]\n\n# Build adjacency list\nadjacency = [Int[] for _ in 1:3]\nfor (idx, edge) in enumerate(edges)\n    push!(adjacency[edge.source], idx)\nend\n\ngraph = MultiObjectiveGraph(\n    3,                      # n_vertices\n    edges,                  # edges\n    2,                      # n_objectives\n    adjacency,              # adjacency list\n    [\"Cost\", \"Time\"]        # objective names\n)\n\n# Compute Pareto front\nsolutions = compute_pareto_front(graph, 1, 3)\n\n# Find best trade-off\nbest = get_knee_point(solutions)\nprintln(\"Best trade-off - Cost: $(best.objectives[1]), Time: $(best.objectives[2])\")","category":"page"},{"location":"examples/#Domain-Specific-Example","page":"Overview","title":"Domain-Specific Example","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"# Drug-target network\ndrugs = [\"Aspirin\", \"Ibuprofen\"]\ntargets = [\"COX1\", \"COX2\"]\naffinities = [\n    (\"Aspirin\", \"COX1\", 2.5),\n    (\"Aspirin\", \"COX2\", 3.2),\n    (\"Ibuprofen\", \"COX1\", 1.8),\n    (\"Ibuprofen\", \"COX2\", 2.1)\n]\n\nnetwork = create_drug_target_network(drugs, targets, affinities)\ndistance, path = find_drug_target_paths(network, \"Aspirin\", \"COX2\")","category":"page"},{"location":"examples/#Visualization-Examples","page":"Overview","title":"Visualization Examples","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"Each example directory includes generate_figures.jl for creating publication-quality visualizations:","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"cd examples/comprehensive_demo\njulia --project=. generate_figures.jl\n# Generates 7 figures in figures/ directory","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"Figures use professional aesthetics:","category":"page"},{"location":"examples/","page":"Overview","title":"Overview","text":"300 DPI resolution\nBookman serif font\nNature/Science journal color palette\nPublication-ready quality","category":"page"},{"location":"examples/#See-Also","page":"Overview","title":"See Also","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"Getting Started for basic usage\nAPI Reference for complete function documentation\nGitHub Examples for source code","category":"page"},{"location":"manual/domains/#Domain-Applications","page":"Domain Applications","title":"Domain Applications","text":"","category":"section"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"OptimShortestPaths provides built-in support for common application domains, particularly in pharmaceutical and healthcare optimization.","category":"page"},{"location":"manual/domains/#Drug-Target-Networks","page":"Domain Applications","title":"Drug-Target Networks","text":"","category":"section"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"Analyze drug-target interactions and selectivity.","category":"page"},{"location":"manual/domains/#Creating-a-Network","page":"Domain Applications","title":"Creating a Network","text":"","category":"section"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"using OptimShortestPaths\n\ndrugs = [\"Aspirin\", \"Ibuprofen\", \"Celecoxib\"]\ntargets = [\"COX1\", \"COX2\", \"5-LOX\", \"PGHS\"]\n\n# Binding affinities (lower = stronger binding)\naffinities = [\n    (\"Aspirin\", \"COX1\", 2.5),\n    (\"Aspirin\", \"COX2\", 3.2),\n    (\"Ibuprofen\", \"COX1\", 1.8),\n    (\"Ibuprofen\", \"COX2\", 2.1),\n    (\"Celecoxib\", \"COX2\", 0.5),  # Highly selective\n]\n\nnetwork = create_drug_target_network(drugs, targets, affinities)","category":"page"},{"location":"manual/domains/#Finding-Paths","page":"Domain Applications","title":"Finding Paths","text":"","category":"section"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"# Find shortest path from drug to target\ndistance, path = find_drug_target_paths(network, \"Aspirin\", \"COX2\")\nprintln(\"Binding affinity: \", distance)","category":"page"},{"location":"manual/domains/#Analyzing-Selectivity","page":"Domain Applications","title":"Analyzing Selectivity","text":"","category":"section"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"# Compare drug affinity for two targets\nratio = calculate_distance_ratio(network.graph, drug_idx, cox1_idx, cox2_idx)\nprintln(\"COX2/COX1 selectivity ratio: \", ratio)\n\n# Analyze overall connectivity\nstats = analyze_drug_connectivity(network, \"Celecoxib\")\nprintln(\"Reachable targets: \", stats)","category":"page"},{"location":"manual/domains/#Metabolic-Pathways","page":"Domain Applications","title":"Metabolic Pathways","text":"","category":"section"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"Optimize biochemical reaction pathways.","category":"page"},{"location":"manual/domains/#Creating-a-Pathway","page":"Domain Applications","title":"Creating a Pathway","text":"","category":"section"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"metabolites = [\"Glucose\", \"G6P\", \"F6P\", \"F16BP\", \"DHAP\", \"G3P\", \"PEP\", \"Pyruvate\", \"ATP\"]\n\nreactions = [\n    (\"Hexokinase\", \"Glucose\", \"G6P\", -1.0),      # ATP cost\n    (\"PGI\", \"G6P\", \"F6P\", 0.0),\n    (\"PFK\", \"F6P\", \"F16BP\", -1.0),               # ATP cost\n    (\"Aldolase\", \"F16BP\", \"DHAP\", 0.0),\n    (\"TPI\", \"DHAP\", \"G3P\", 0.0),\n    (\"GAPDH\", \"G3P\", \"PEP\", 2.0),                # ATP production\n    (\"PK\", \"PEP\", \"Pyruvate\", 2.0),              # ATP production\n]\n\npathway = create_metabolic_pathway(metabolites, reactions)","category":"page"},{"location":"manual/domains/#Finding-Optimal-Pathways","page":"Domain Applications","title":"Finding Optimal Pathways","text":"","category":"section"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"# Find pathway from substrate to product\natp_cost, pathway_steps = find_metabolic_pathway(pathway, \"Glucose\", \"Pyruvate\")\nprintln(\"Net ATP yield: \", -atp_cost)  # Negative cost = ATP production\nprintln(\"Pathway: \", pathway_steps)","category":"page"},{"location":"manual/domains/#Treatment-Protocols","page":"Domain Applications","title":"Treatment Protocols","text":"","category":"section"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"Optimize clinical treatment sequences.","category":"page"},{"location":"manual/domains/#Creating-a-Protocol","page":"Domain Applications","title":"Creating a Protocol","text":"","category":"section"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"treatments = [\"Initial\", \"ChemoA\", \"ChemoB\", \"Surgery\", \"Radiation\", \"Remission\"]\n\n# Costs in thousands of dollars\ncosts = [0.0, 50.0, 60.0, 100.0, 40.0, 0.0]\n\n# Efficacy weights (higher = better outcome)\nefficacy = [0.0, 0.6, 0.7, 0.8, 0.5, 1.0]\n\n# Valid treatment transitions (from, to, additional_risk)\ntransitions = [\n    (\"Initial\", \"ChemoA\", 0.1),\n    (\"Initial\", \"Surgery\", 0.3),\n    (\"ChemoA\", \"ChemoB\", 0.05),\n    (\"ChemoA\", \"Surgery\", 0.2),\n    (\"ChemoB\", \"Radiation\", 0.15),\n    (\"Surgery\", \"Radiation\", 0.1),\n    (\"Radiation\", \"Remission\", 0.05),\n]\n\nprotocol = create_treatment_protocol(treatments, costs, efficacy, transitions)","category":"page"},{"location":"manual/domains/#Optimizing-Sequences","page":"Domain Applications","title":"Optimizing Sequences","text":"","category":"section"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"# Find lowest-cost path to remission\ntotal_cost, sequence = optimize_treatment_sequence(protocol, \"Initial\", \"Remission\")\n\nprintln(\"Total cost: \\$\", total_cost * 1000)\nprintln(\"Optimal sequence: \", sequence)","category":"page"},{"location":"manual/domains/#Supply-Chain-Optimization","page":"Domain Applications","title":"Supply Chain Optimization","text":"","category":"section"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"For custom domains like supply chain, use the generic interface:","category":"page"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"# Entities: Factories, warehouses, distribution centers\n# Edges: Transportation links\n# Weights: Shipping cost + inventory holding cost\n\nfactories = 3\nwarehouses = 4\ndist_centers = 5\nn_vertices = factories + warehouses + dist_centers\n\nedges = Edge[]\nweights = Float64[]\n\n# Factory → Warehouse links\nfor f in 1:factories\n    for w in 1:warehouses\n        from = f\n        to = factories + w\n        transport_cost = rand(10:20)\n        push!(edges, Edge(from, to, length(edges)+1))\n        push!(weights, float(transport_cost))\n    end\nend\n\n# Warehouse → Distribution center links\nfor w in 1:warehouses\n    for d in 1:dist_centers\n        from = factories + w\n        to = factories + warehouses + d\n        cost = rand(5:15)\n        push!(edges, Edge(from, to, length(edges)+1))\n        push!(weights, float(cost))\n    end\nend\n\ngraph = DMYGraph(n_vertices, edges, weights)\n\n# Find optimal route from factory 1 to dist center 3\ntarget = factories + warehouses + 3\ndistances = dmy_sssp!(graph, 1)\nprintln(\"Minimum cost to DC 3: \\$\", distances[target])","category":"page"},{"location":"manual/domains/#Generic-Pattern","page":"Domain Applications","title":"Generic Pattern","text":"","category":"section"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"All domain applications follow this pattern:","category":"page"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"Define entities (metabolites, drugs, locations, etc.)\nDefine relationships (reactions, bindings, routes, etc.)\nAssign costs/weights (affinities, times, distances, etc.)\nCreate graph using domain constructor or generic DMYGraph\nRun algorithm to find optimal solutions","category":"page"},{"location":"manual/domains/#See-Also","page":"Domain Applications","title":"See Also","text":"","category":"section"},{"location":"manual/domains/","page":"Domain Applications","title":"Domain Applications","text":"Problem Transformation for general framework\nAPI Reference - Domain Functions\nExamples for complete worked examples","category":"page"},{"location":"#OptimShortestPaths.jl","page":"Home","title":"OptimShortestPaths.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Transform optimization problems into graph shortest paths using the efficient DMY algorithm","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OptimShortestPaths is a Julia package that provides a unified framework for solving optimization problems by transforming them into shortest-path problems on directed graphs. The package implements the state-of-the-art DMY (Duan-Mao-Yin) algorithm from STOC 2025, achieving O(m log^(2/3) n) time complexity for single-source shortest paths.","category":"page"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Efficient Algorithm: DMY algorithm with O(m log^(2/3) n) complexity\nMulti-Objective: Pareto front computation with bounded solutions\nDomain-Agnostic: Transform ANY optimization problem to shortest paths\nDomain-Specific: Built-in support for drug discovery, metabolic networks, treatment protocols\nWell-Tested: Over 1,900 passing tests with 100% pass rate\nPublication-Quality: Professional figures and comprehensive benchmarks","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"OptimShortestPaths\")\nusing OptimShortestPaths\n\n# Create a graph\nedges = [Edge(1, 2, 1), Edge(2, 3, 2), Edge(1, 3, 3)]\nweights = [1.0, 2.0, 4.0]\ngraph = DMYGraph(3, edges, weights)\n\n# Run DMY algorithm\ndistances = dmy_sssp!(graph, 1)  # Source vertex 1\nprintln(\"Distances: \", distances)  # [0.0, 1.0, 3.0]","category":"page"},{"location":"#Cheat-Sheet","page":"Home","title":"Cheat Sheet","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For a comprehensive, example-driven overview, see the Cheat Sheet page. It includes:\nCore shortest-path usage with line-by-line annotations\nUtilities, validations, and analysis helpers\nMulti-objective strategies and topology diagrams\nA categorized function reference and detailed output-key tables","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package requires Julia 1.9 or later:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"OptimShortestPaths\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"For development version:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.develop(\"OptimShortestPaths\")","category":"page"},{"location":"#Core-Concepts","page":"Home","title":"Core Concepts","text":"","category":"section"},{"location":"#Problem-Transformation-Philosophy","page":"Home","title":"Problem Transformation Philosophy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OptimShortestPaths transforms optimization problems into shortest-path problems:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Entities → Vertices: Map domain objects to graph vertices\nRelationships → Edges: Convert interactions/transitions to directed edges\nObjectives → Weights: Transform costs to non-negative edge weights\nSolutions → Paths: Shortest paths = optimal solutions","category":"page"},{"location":"#Why-This-Approach?","page":"Home","title":"Why This Approach?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Unified Framework: One algorithm solves many problems\nEfficient: O(m log^(2/3) n) complexity beats many domain-specific methods\nFlexible: Generic graph utilities work for any domain\nProven: Based on award-winning STOC 2025 algorithm","category":"page"},{"location":"#Main-Components","page":"Home","title":"Main Components","text":"","category":"section"},{"location":"#Core-Algorithm","page":"Home","title":"Core Algorithm","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"dmy_sssp! - Main DMY shortest path algorithm\nDMYGraph - Graph data structure\nbmssp! - Bounded Multi-Source Shortest Path subroutine","category":"page"},{"location":"#Multi-Objective-Optimization","page":"Home","title":"Multi-Objective Optimization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"compute_pareto_front - Pareto front computation\nweighted_sum_approach - Scalarization method\nepsilon_constraint_approach - ε-constraint method","category":"page"},{"location":"#Domain-Applications","page":"Home","title":"Domain Applications","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Drug-target network analysis\nMetabolic pathway optimization\nTreatment protocol sequencing\nSupply chain optimization","category":"page"},{"location":"#Performance","page":"Home","title":"Performance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Benchmarks on sparse random graphs (m ≈ 2n):","category":"page"},{"location":"","page":"Home","title":"Home","text":"Graph Size DMY Time Dijkstra Time Speedup\n200 0.08 ms 0.02 ms 0.31×\n500 0.43 ms 0.17 ms 0.39×\n1,000 1.46 ms 0.64 ms 0.44×\n2,000 1.42 ms 2.51 ms 1.77×\n5,000 3.35 ms 16.03 ms 4.79×","category":"page"},{"location":"","page":"Home","title":"Home","text":"DMY becomes faster than Dijkstra at approximately n ≈ 1,800 vertices.","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use OptimShortestPaths in your research, please cite:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@software{optimshortestpaths2025,\n  title = {OptimShortestPaths: Optimization via Shortest Paths},\n  author = {Tianchi Chen},\n  year = {2025},\n  url = {https://github.com/danielchen26/OptimShortestPaths.jl}\n}\n\n@inproceedings{dmy2025,\n  title = {Breaking the Dijkstra Barrier for Directed Single-Source Shortest-Paths via Structured Distances},\n  author = {Duan, Ran and Mao, Jiawei and Yin, Hao and Zhou, Hengming},\n  booktitle = {Proceedings of the 57th Annual ACM Symposium on Theory of Computing (STOC 2025)},\n  year = {2025},\n  note = {Best Paper Award}\n}","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributions are welcome! Please:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Add tests for new features\nUpdate benchmarks with your hardware specs\nCite relevant papers for algorithmic contributions\nFollow Julia style guidelines","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MIT License - see LICENSE file for details.","category":"page"},{"location":"#Acknowledgments","page":"Home","title":"Acknowledgments","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The DMY algorithm implementation is based on the STOC 2025 Best Paper by Duan, Mao, Yin, and Zhou.","category":"page"},{"location":"manual/multiobjective/#Multi-Objective-Optimization","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"","category":"section"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"OptimShortestPaths provides comprehensive support for multi-objective optimization through Pareto front computation.","category":"page"},{"location":"manual/multiobjective/#Overview","page":"Multi-Objective Optimization","title":"Overview","text":"","category":"section"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"When you have multiple conflicting objectives (e.g., minimize cost AND minimize time), there's no single \"best\" solution. Instead, you need to find the Pareto front - the set of solutions where improving one objective requires sacrificing another.","category":"page"},{"location":"manual/multiobjective/#Computing-the-Pareto-Front","page":"Multi-Objective Optimization","title":"Computing the Pareto Front","text":"","category":"section"},{"location":"manual/multiobjective/#Basic-Usage","page":"Multi-Objective Optimization","title":"Basic Usage","text":"","category":"section"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"using OptimShortestPaths\nusing OptimShortestPaths.MultiObjective\n\n# Create multi-objective graph\nedges = [\n    MultiObjectiveEdge(1, 2, [1.0, 5.0], 1),  # [cost, time] for edge 1->2\n    MultiObjectiveEdge(2, 3, [2.0, 1.0], 2)   # [cost, time] for edge 2->3\n]\n\n# Build adjacency list\nadjacency = [Int[] for _ in 1:3]\nfor (idx, edge) in enumerate(edges)\n    push!(adjacency[edge.source], idx)\nend\n\ngraph = MultiObjectiveGraph(\n    3,                      # n_vertices\n    edges,                  # edges with weights\n    2,                      # n_objectives\n    adjacency,              # adjacency list\n    [\"Cost\", \"Time\"]        # objective names\n)\n\nsource = 1\ntarget = 3\n\n# Compute Pareto front\npareto_solutions = compute_pareto_front(graph, source, target; max_solutions=1000)\n\n# Each solution has:\nfor sol in pareto_solutions\n    println(\"Objectives: \", sol.objectives)  # [total_cost, total_time]\n    println(\"Path: \", sol.path)              # Vertex sequence\nend","category":"page"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"All upcoming examples repeat this lightweight setup so each block can be copied into a fresh Julia REPL and run on its own. If you are working through the page sequentially, feel free to skip the duplicated using and graph-construction code and reuse the graph, source, and target variables already in scope.","category":"page"},{"location":"manual/multiobjective/#Bounded-Pareto-Computation","page":"Multi-Objective Optimization","title":"Bounded Pareto Computation","text":"","category":"section"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"To prevent exponential growth of the Pareto set:","category":"page"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"using OptimShortestPaths\nusing OptimShortestPaths.MultiObjective\n\nedges = [\n    MultiObjectiveEdge(1, 2, [1.0, 5.0], 1),\n    MultiObjectiveEdge(2, 3, [2.0, 1.0], 2)\n]\n\nadjacency = [Int[] for _ in 1:3]\nfor (idx, edge) in enumerate(edges)\n    push!(adjacency[edge.source], idx)\nend\n\ngraph = MultiObjectiveGraph(3, edges, 2, adjacency, [\"Cost\", \"Time\"])\nsource = 1\ntarget = 3\n\npareto_solutions = compute_pareto_front(\n    graph, source, target;\n    max_solutions=1000  # Stop after 1000 solutions\n)","category":"page"},{"location":"manual/multiobjective/#Scalarization-Methods","page":"Multi-Objective Optimization","title":"Scalarization Methods","text":"","category":"section"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"Each helper in this section returns a ParetoSolution, giving you direct access to the objectives vector and reconstructed path.","category":"page"},{"location":"manual/multiobjective/#Weighted-Sum-Approach","page":"Multi-Objective Optimization","title":"Weighted Sum Approach","text":"","category":"section"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"Convert multiple objectives into a single weighted sum:","category":"page"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"using OptimShortestPaths\nusing OptimShortestPaths.MultiObjective\n\nedges = [\n    MultiObjectiveEdge(1, 2, [1.0, 5.0], 1),\n    MultiObjectiveEdge(2, 3, [2.0, 1.0], 2)\n]\n\nadjacency = [Int[] for _ in 1:3]\nfor (idx, edge) in enumerate(edges)\n    push!(adjacency[edge.source], idx)\nend\n\ngraph = MultiObjectiveGraph(3, edges, 2, adjacency, [\"Cost\", \"Time\"])\nsource = 1\ntarget = 3\n\nweights = [0.7, 0.3]  # 70% cost, 30% time\nsolution = weighted_sum_approach(graph, source, target, weights)\nprintln(\"Objectives: \", solution.objectives)\nprintln(\"Path: \", solution.path)","category":"page"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"warning: Minimization Only\nweighted_sum_approach currently requires all objectives to be minimization (:min). Transform maximization objectives first.","category":"page"},{"location":"manual/multiobjective/#Epsilon-Constraint-Method","page":"Multi-Objective Optimization","title":"Epsilon-Constraint Method","text":"","category":"section"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"Optimize one objective while constraining others:","category":"page"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"using OptimShortestPaths\nusing OptimShortestPaths.MultiObjective\n\nedges = [\n    MultiObjectiveEdge(1, 2, [1.0, 5.0], 1),\n    MultiObjectiveEdge(2, 3, [2.0, 1.0], 2)\n]\n\nadjacency = [Int[] for _ in 1:3]\nfor (idx, edge) in enumerate(edges)\n    push!(adjacency[edge.source], idx)\nend\n\ngraph = MultiObjectiveGraph(3, edges, 2, adjacency, [\"Cost\", \"Time\"])\nsource = 1\ntarget = 3\n\n# Minimize cost subject to: time ≤ 10.0\nsolution = epsilon_constraint_approach(\n    graph, source, target,\n    1,              # Objective index to minimize (cost)\n    [Inf, 10.0]     # Constraints on objectives [cost, time]\n)\nprintln(\"Objectives: \", solution.objectives)\nprintln(\"Path: \", solution.path)","category":"page"},{"location":"manual/multiobjective/#Lexicographic-Optimization","page":"Multi-Objective Optimization","title":"Lexicographic Optimization","text":"","category":"section"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"Optimize objectives in priority order:","category":"page"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"using OptimShortestPaths\nusing OptimShortestPaths.MultiObjective\n\nedges = [\n    MultiObjectiveEdge(1, 2, [1.0, 5.0], 1),\n    MultiObjectiveEdge(2, 3, [2.0, 1.0], 2)\n]\n\nadjacency = [Int[] for _ in 1:3]\nfor (idx, edge) in enumerate(edges)\n    push!(adjacency[edge.source], idx)\nend\n\ngraph = MultiObjectiveGraph(3, edges, 2, adjacency, [\"Cost\", \"Time\"])\nsource = 1\ntarget = 3\n\npriorities = [1, 2]  # First minimize obj 1 (cost), then obj 2 (time)\nsolution = lexicographic_approach(graph, source, target, priorities)\nprintln(\"Objectives: \", solution.objectives)\nprintln(\"Path: \", solution.path)","category":"page"},{"location":"manual/multiobjective/#Decision-Support","page":"Multi-Objective Optimization","title":"Decision Support","text":"","category":"section"},{"location":"manual/multiobjective/#Finding-the-Knee-Point","page":"Multi-Objective Optimization","title":"Finding the Knee Point","text":"","category":"section"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"The \"knee point\" offers the best trade-off between objectives:","category":"page"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"pareto_solutions = compute_pareto_front(graph, source, target)\n\n# Find solution with best trade-off\nbest_solution = get_knee_point(pareto_solutions)\n\nprintln(\"Best trade-off: \", best_solution.objectives)\nprintln(\"Path: \", best_solution.path)","category":"page"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"The knee point maximizes the angle between solutions, representing the steepest change in the Pareto curve.","category":"page"},{"location":"manual/multiobjective/#Working-with-Objective-Senses","page":"Multi-Objective Optimization","title":"Working with Objective Senses","text":"","category":"section"},{"location":"manual/multiobjective/#Minimization-and-Maximization","page":"Multi-Objective Optimization","title":"Minimization and Maximization","text":"","category":"section"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"# Define mixed objectives\nedges = [MultiObjectiveEdge(1, 2, [5.0, 8.0], 1)]  # [cost_to_minimize, profit_to_maximize]\n\n# Build adjacency list\nadjacency = [Int[] for _ in 1:2]\npush!(adjacency[1], 1)\n\n# Specify senses\ngraph = MultiObjectiveGraph(\n    2,                               # n_vertices\n    edges,                           # edges\n    2,                               # n_objectives\n    adjacency,                       # adjacency list\n    [\"Cost\", \"Profit\"],              # objective names\n    objective_sense = [:min, :max]   # Minimize cost, maximize profit\n)\n\n# Pareto front respects both senses\npareto_front = compute_pareto_front(graph, 1, 2)","category":"page"},{"location":"manual/multiobjective/#Converting-Maximization-to-Minimization","page":"Multi-Objective Optimization","title":"Converting Maximization to Minimization","text":"","category":"section"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"For scalarization methods that require :min:","category":"page"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"# Original: maximize profit\n# Transform: minimize negative profit\n\noriginal_profit = 100.0\nminimization_objective = -original_profit\n\n# Or subtract from baseline\nbaseline = 1000.0\nminimization_objective = baseline - original_profit","category":"page"},{"location":"manual/multiobjective/#Example:-Cost-Time-Trade-off","page":"Multi-Objective Optimization","title":"Example: Cost-Time Trade-off","text":"","category":"section"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"using OptimShortestPaths\nusing OptimShortestPaths.MultiObjective\n\n# Supply chain network: minimize cost AND time\nedges = [\n    MultiObjectiveEdge(1, 2, [10.0, 1.0], 1),  # Cheap but slow\n    MultiObjectiveEdge(1, 3, [30.0, 0.5], 2),  # Expensive but fast\n    MultiObjectiveEdge(2, 4, [5.0, 2.0], 3),   # Cheap and slow\n    MultiObjectiveEdge(3, 4, [15.0, 1.0], 4)   # Moderate\n]\n\n# Build adjacency list\nadjacency = [Int[] for _ in 1:4]\nfor (idx, edge) in enumerate(edges)\n    push!(adjacency[edge.source], idx)\nend\n\ngraph = MultiObjectiveGraph(\n    4,                      # n_vertices\n    edges,                  # edges\n    2,                      # n_objectives (cost, time)\n    adjacency,              # adjacency list\n    [\"Cost\", \"Time\"]        # objective names\n)\n\n# Find all Pareto-optimal paths\npareto_front = compute_pareto_front(graph, 1, 4)\n\nprintln(\"Found \", length(pareto_front), \" Pareto-optimal solutions:\")\nfor (i, sol) in enumerate(pareto_front)\n    println(\"  $i. Cost: $(sol.objectives[1]), Time: $(sol.objectives[2])\")\nend\n\n# Select best trade-off\nbest = get_knee_point(pareto_front)\nprintln(\"\\nBest trade-off: Cost=$(best.objectives[1]), Time=$(best.objectives[2])\")","category":"page"},{"location":"manual/multiobjective/#Performance-Considerations","page":"Multi-Objective Optimization","title":"Performance Considerations","text":"","category":"section"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"Pareto set size: Can grow exponentially; use max_solutions to bound it\nNumber of objectives: 2-3 objectives typical; 4+ can be slow\nGraph size: Pareto computation is slower than single-objective\nDominated solutions: Automatically filtered during computation","category":"page"},{"location":"manual/multiobjective/#See-Also","page":"Multi-Objective Optimization","title":"See Also","text":"","category":"section"},{"location":"manual/multiobjective/","page":"Multi-Objective Optimization","title":"Multi-Objective Optimization","text":"API Reference - Multi-Objective\nExamples for more complex scenarios","category":"page"}]
}
